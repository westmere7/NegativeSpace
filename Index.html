<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>exposr</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow-x: hidden;
            overflow-y: scroll;
        }

        header {
            text-align: center;
            padding: 2.1rem 1rem;
            background: #0a0a0a;
            position: relative;
        }

        .logo {
            height: 20px;
            /* Smaller logo */
            width: auto;
            display: block;
            margin: 0 auto;
            opacity: 0.9;
        }

        .gallery {
            padding: 0 1rem;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            /* 3 Columns like reference */
            gap: 24px;
            grid-auto-rows: 20px;
            /* Base row height for masonry calculations */
            grid-auto-flow: dense;
            width: 100%;
            max-width: 1600px;
            /* Constrain width */
            margin: 0 auto;
            /* Center gallery */
        }

        @media (max-width: 1200px) {
            .gallery {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            .gallery {
                grid-template-columns: 1fr;
            }

            /* Force single column spans on mobile to prevent overflow/misalignment */
            .w-1,
            .w-2,
            .w-3 {
                grid-column: span 1 !important;
            }
        }

        .photo-item {
            position: relative;
            cursor: pointer;
            overflow: hidden;
            background: #111;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease, transform 0.6s ease;

            content-visibility: auto;
            contain-intrinsic-size: 1px 600px;
        }

        .photo-item.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .photo-item img {
            width: 100%;
            height: 100%;
            display: block;
            transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s;
            object-fit: cover;
            border-radius: 0;
            opacity: 0;
        }

        .photo-item img.loaded {
            opacity: 1;
        }

        .photo-item:hover img {
            transform: scale(1.03);
        }

        /* Grid Spans */
        .w-1 {
            grid-column: span 1;
        }

        .w-2 {
            grid-column: span 2;
        }

        .w-3 {
            grid-column: span 3;
        }



        .photo-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 2rem 1.5rem 1.5rem;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 0.9rem;
            /* Increased from 0.75rem */
            pointer-events: none;
        }

        .photo-item:hover .photo-info {
            opacity: 1;
        }

        .photo-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.2rem;
            letter-spacing: 0.02em;
        }

        .photo-date {
            font-size: 0.85rem;
            color: #ccc;
            margin-bottom: 0.2rem;
            font-weight: 500;
        }

        .info-line {
            line-height: 1.4;
            color: #aaa;
            font-weight: 400;
        }

        /* Lightbox */
        .lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.98);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .lightbox.active {
            display: flex;
        }

        .lightbox-close {
            position: absolute;
            top: 1.5rem;
            right: 2rem;
            background: none;
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            z-index: 1010;
            opacity: 0.7;
            transition: opacity 0.2s;
            padding: 10px;
        }

        .lightbox-close:hover {
            opacity: 1;
        }

        .lightbox-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 3rem;
            cursor: pointer;
            padding: 2rem;
            z-index: 1010;
            transition: color 0.2s;
        }

        .lightbox-arrow:hover {
            color: #fff;
        }

        .arrow-prev {
            left: 0;
        }

        .arrow-next {
            right: 0;
        }

        .lightbox-content {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            overflow: hidden;
            padding-bottom: 2rem;
        }

        .lightbox-img-wrapper {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            overflow: hidden;
        }

        .lightbox-img-wrapper:active {
            cursor: grabbing;
        }

        .lightbox img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transform-origin: 0 0;
            will-change: transform;
            user-select: none;
        }

        .lightbox-overlay {
            position: relative;
            width: 100%;
            text-align: center;
            pointer-events: none;
            padding-top: 1rem;
            color: #888;
            flex-shrink: 0;
            left: auto;
            bottom: auto;
            transform: none;
            text-shadow: none;
        }

        .lightbox-title {
            font-size: 1rem;
            font-weight: 500;
            color: #fff;
        }

        .lightbox-meta {
            font-size: 0.8rem;
            color: #aaa;
            margin-top: 0.3rem;
        }

        .loading-sentinel {
            width: 100%;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            margin-top: 2rem;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            border-top: 2px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <header>
        <img src="Website assets/exposr_name.svg" alt="exposr" class="logo">
    </header>

    <div class="gallery" id="gallery"></div>
    <div class="loading-sentinel" id="sentinel">
        <div class="spinner"></div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <button class="lightbox-close" onclick="closeLightbox()">×</button>
        <button class="lightbox-arrow arrow-prev" onclick="navigate(-1)">‹</button>
        <button class="lightbox-arrow arrow-next" onclick="navigate(1)">›</button>

        <div class="lightbox-content">
            <div class="lightbox-img-wrapper" id="zoom-container">
                <img id="lightbox-img" src="" alt="">
            </div>
            <div class="lightbox-overlay" id="lightbox-info"></div>
        </div>
    </div>

    <script>
        // State
        const state = {
            allPhotos: [],
            loadedCount: 0,
            batchSize: 12,
            currentIndex: 0,
            isLoading: false
        };

        const zoom = {
            scale: 1,
            panning: false,
            pointX: 0,
            pointY: 0,
            startX: 0,
            startY: 0
        };

        // DOM Elements
        const gallery = document.getElementById('gallery');
        const sentinel = document.getElementById('sentinel');
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = document.getElementById('lightbox-img');
        const zoomContainer = document.getElementById('zoom-container');

        // Initialize
        async function init() {
            try {
                const response = await fetch('photos.json');
                state.allPhotos = await response.json();

                if (state.allPhotos.length === 0) {
                    sentinel.innerHTML = 'No photos found.';
                    return;
                }

                // Initial load
                loadMorePhotos();

                // Setup Infinite Scroll
                const observer = new IntersectionObserver((entries) => {
                    if (entries[0].isIntersecting && !state.isLoading) {
                        loadMorePhotos();
                    }
                }, { rootMargin: '200px' });

                observer.observe(sentinel);

            } catch (error) {
                console.error('Failed to load photos:', error);
                sentinel.innerHTML = 'Error loading photos.';
            }
        }

        function loadMorePhotos() {
            if (state.loadedCount >= state.allPhotos.length) {
                sentinel.style.display = 'none';
                return;
            }

            state.isLoading = true;
            const batch = state.allPhotos.slice(state.loadedCount, state.loadedCount + state.batchSize);

            batch.forEach((filename, i) => {
                const globalIndex = state.loadedCount + i;
                createPhotoElement(filename, globalIndex);
            });

            state.loadedCount += batch.length;
            state.isLoading = false;
        }

        function createPhotoElement(filename, index) {
            const item = document.createElement('div');
            item.className = 'photo-item';

            const img = document.createElement('img');
            img.src = `Photos/${filename}`;
            img.loading = 'lazy';

            const info = document.createElement('div');
            info.className = 'photo-info';

            // Wait for image dimensions to determine grid span
            img.onload = function () {
                img.classList.add('loaded');
                item.classList.add('visible');

                const ratio = this.naturalWidth / this.naturalHeight;
                assignGridSpan(item, ratio);

                // Load EXIF
                EXIF.getData(img, function () {
                    const exifData = EXIF.getAllTags(this);
                    const meta = extractExifInfo(exifData);
                    info.innerHTML = meta.html;

                    // Store metadata for lightbox
                    state.allPhotos[index] = {
                        src: `Photos/${filename}`,
                        meta: meta,
                        ...state.allPhotos[index]
                    };
                    img.dataset.metaTitle = meta.title;
                    img.dataset.metaDetails = meta.details;
                    img.dataset.metaDate = meta.date;
                });
            };

            item.appendChild(img);
            item.appendChild(info);
            item.onclick = () => openLightbox(index);
            gallery.appendChild(item);
        }

        function assignGridSpan(element, ratio) {
            // Store ratio for potential resize recalculations
            element.dataset.ratio = ratio;

            // 1. Assign Width randomly (keep variety) if not already assigned
            // We check if it has a width class? No, just overwrite or set.
            // But we should only set w-class once to avoid jumping on resize.
            // Check if w-1 or w-2 is present?
            let hasWidth = element.classList.contains('w-1') || element.classList.contains('w-2');

            if (!hasWidth) {
                const rand = Math.random();
                element.classList.remove('h-1', 'h-2'); // clear previous h classes if any (unused now)

                if (ratio > 1.2) {
                    // Landscape
                    if (rand > 0.6) { element.classList.add('w-2'); } // Wide
                    else { element.classList.add('w-1'); } // Regular
                } else if (ratio < 0.8) {
                    // Portrait
                    if (rand > 0.8) { element.classList.add('w-2'); } // Big Portrait (rare)
                    else { element.classList.add('w-1'); } // Regular
                } else {
                    // Square-ish
                    if (rand > 0.85) { element.classList.add('w-2'); } // Big Square
                    else { element.classList.add('w-1'); } // Regular
                }
            }

            // 2. Calculate Row Span
            const width = element.offsetWidth;
            if (width > 0) {
                const targetHeight = width / ratio;
                const rowHeight = 20; // Matches CSS grid-auto-rows
                const gap = 24;       // Matches CSS gap

                // span = (height + gap) / (rowHeight + gap)
                const rowSpan = Math.ceil((targetHeight + gap) / (rowHeight + gap));
                element.style.gridRowEnd = `span ${rowSpan}`;
            }
        }

        // recalculate on resize
        window.addEventListener('resize', () => {
            const items = document.querySelectorAll('.photo-item');
            items.forEach(item => {
                if (item.dataset.ratio) {
                    assignGridSpan(item, parseFloat(item.dataset.ratio));
                }
            });
        });

        function extractExifInfo(exif) {
            const title = exif.ImageDescription || '';
            const details = [];

            // Camera Model
            if (exif.Model) details.push(exif.Model);

            // Lens (check LensModel and Lens)
            if (exif.LensModel) details.push(exif.LensModel);
            else if (exif.Lens) details.push(exif.Lens);

            // Focal Length (standard or 35mm equiv)
            if (exif.FocalLength) {
                details.push(`${Math.round(Number(exif.FocalLength))}mm`);
            } else if (exif.FocalLengthIn35mmFilm) {
                details.push(`${exif.FocalLengthIn35mmFilm}mm`);
            }

            // Aperture
            if (exif.FNumber) details.push(`f/${exif.FNumber}`);

            // Shutter Speed
            if (exif.ExposureTime) {
                const t = exif.ExposureTime;
                details.push(t < 1 ? `1/${Math.round(1 / t)}s` : `${t}s`);
            }

            // ISO
            if (exif.ISOSpeedRatings) details.push(`ISO ${exif.ISOSpeedRatings}`);

            // EV (Robust check)
            if (exif.ExposureBiasValue !== undefined && exif.ExposureBiasValue !== null) {
                const ev = Number(exif.ExposureBiasValue);
                if (!isNaN(ev)) {
                    const sign = ev > 0 ? '+' : '';
                    details.push(`${sign}${ev.toFixed(1)} EV`);
                }
            }

            const detailsStr = details.join(' · ');

            // Parsing Date Time Original
            let dateStr = '';
            if (exif.DateTimeOriginal) {
                const match = exif.DateTimeOriginal.match(/^(\d{4}):(\d{2}):(\d{2})\s(\d{2}):(\d{2})/);
                if (match) {
                    dateStr = `${match[1]}-${match[2]}-${match[3]} ${match[4]}:${match[5]}`;
                } else {
                    dateStr = exif.DateTimeOriginal;
                }
            }

            return {
                title: title,
                details: detailsStr,
                date: dateStr,
                html: `
                    ${title ? `<div class="photo-title">${title}</div>` : ''}
                    ${dateStr ? `<div class="photo-date">${dateStr}</div>` : ''}
                    <div class="info-line">${detailsStr}</div>
                `
            };
        }

        // --- Lightbox Logic ---

        function openLightbox(index) {
            state.currentIndex = index;
            updateLightboxContent();
            lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeLightbox() {
            lightbox.classList.remove('active');
            document.body.style.overflow = 'auto'; // restore scroll
            resetZoom();
        }

        function navigate(dir) {
            // Find actual number of loaded items to avoid bounds error if we clicked a not-yet-loaded index?
            // Actually relying on DOM elements for source is safer.
            const items = document.querySelectorAll('.photo-item img');
            state.currentIndex = (state.currentIndex + dir + items.length) % items.length;
            updateLightboxContent();
        }

        function updateLightboxContent() {
            const items = document.querySelectorAll('.photo-item img');
            const targetImg = items[state.currentIndex];

            if (!targetImg) return;

            lightboxImg.src = targetImg.src;

            const infoBox = document.getElementById('lightbox-info');
            const title = targetImg.dataset.metaTitle || '';
            const details = targetImg.dataset.metaDetails || '';
            const date = targetImg.dataset.metaDate || '';

            infoBox.innerHTML = `
                ${title ? `<div class="lightbox-title">${title}</div>` : ''}
                <div class="lightbox-meta">
                    ${date ? `<span>${date}</span>` : ''}
                    ${date && details ? ' · ' : ''}
                    ${details}
                </div>
            `;

            resetZoom();
        }

        // --- Zoom & Pan Logic (Cursor Centered) ---

        function resetZoom() {
            zoom.scale = 1;
            zoom.pointX = 0;
            zoom.pointY = 0;
            applyTransform();
        }

        function applyTransform() {
            lightboxImg.style.transform = `translate(${zoom.pointX}px, ${zoom.pointY}px) scale(${zoom.scale})`;
        }

        zoomContainer.addEventListener('wheel', (e) => {
            e.preventDefault();

            // 1. Get mouse position relative to the image container
            const rect = zoomContainer.getBoundingClientRect();
            // We want the position relative to the center of the viewport/container because our transform origin is not set to 0 0 in CSS?
            // Wait, in CSS I set transform-origin: 0 0; 
            // This simplifies math: everything starts at top-left.
            // Actually, centering the image is done by flexbox.
            // Let's use the image's own rect.

            const imgRect = lightboxImg.getBoundingClientRect();

            // Mouse position relative to the image's current top-left
            const mouseX = e.clientX - imgRect.left;
            const mouseY = e.clientY - imgRect.top;

            // Determine new scale
            const delta = -Math.sign(e.deltaY) * 0.5;
            const newScale = Math.min(Math.max(1, zoom.scale + delta), 5);

            if (newScale === zoom.scale) return; // No change

            // 2. Adjust translation
            // Logic: The point under the mouse (mouseX, mouseY) should remain at the same screen coordinate.
            // (mouseX / oldScale) = "original pixel x"
            // We want (original pixel x) * newScale + newTranslateX = ScreenX (where ScreenX is e.clientX - container.left?? No.)

            // Standard Zoom-at-point algorithm:
            // translate -= (mouseX / scale) * (newScale - scale)
            // But we need to account for our specific transform setup.

            // Let's do it relative to the current translation (zoom.pointX/Y).
            // The coordinate in "unscaled local space" is:
            // localX = (e.clientX - (containerRect.left + containerWidth/2 - imgWidth/2) - currentTranslateX) / currentScale
            // This is getting complicated because of Flex centering.

            /* Simplified Approach that works robustly with transform-origin: 0 0 */
            /* We need to track the "virtual" top-left corner */

            const contentRect = zoomContainer.getBoundingClientRect();
            // Calculate mouse offset from the content center (where image is centered broadly) is not enough.

            // Let's stick to the relative shift.
            // The mouse is at `e.clientX`, `e.clientY`.
            // The image is currently at `imgRect.left`, `imgRect.top`.
            // The point clicked on the image is `ptrX = (e.clientX - imgRect.left) / zoom.scale`.

            // After scaling, we want that same point `ptrX` to be at `e.clientX`.
            // So: `imgNewLeft + ptrX * newScale = e.clientX`
            // `imgNewLeft = e.clientX - ptrX * newScale`

            // We control `zoom.pointX/Y`. 
            // Note: `imgRect.left` includes the flexbox centering offset! 
            // We can't easily control that via `translate`.
            // BUT: `transform` is applied *after* layout.
            // If `transform-origin` is `0 0`, the transform applies to the top-left of the element.
            // The element is centered by flex.

            // Let MainOffset be the offset of the image top-left from window 0,0 when scale=1, translate=0.
            // We can calculate BaseX = imgRect.left - zoom.pointX.

            const BaseX = imgRect.left - zoom.pointX;
            const BaseY = imgRect.top - zoom.pointY;

            const ptrX = (e.clientX - imgRect.left) / zoom.scale;
            const ptrY = (e.clientY - imgRect.top) / zoom.scale;

            zoom.scale = newScale;

            // New position (left/top)
            // NewLeft = BaseX + newTranslateX
            // We want: NewLeft + ptrX * newScale = e.clientX
            // BaseX + newTranslateX + ptrX * newScale = e.clientX
            // newTranslateX = e.clientX - BaseX - ptrX * newScale

            zoom.pointX = e.clientX - BaseX - (ptrX * newScale);
            zoom.pointY = e.clientY - BaseY - (ptrY * newScale);

            applyTransform();
        });

        // Pan Support
        zoomContainer.addEventListener('mousedown', (e) => {
            if (zoom.scale <= 1) return;
            e.preventDefault();
            zoom.panning = true;
            zoom.startX = e.clientX - zoom.pointX;
            zoom.startY = e.clientY - zoom.pointY;
        });

        document.addEventListener('mousemove', (e) => {
            if (!zoom.panning) return;
            e.preventDefault();
            zoom.pointX = e.clientX - zoom.startX;
            zoom.pointY = e.clientY - zoom.startY;
            applyTransform();
        });

        document.addEventListener('mouseup', () => {
            zoom.panning = false;
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (!lightbox.classList.contains('active')) return;
            if (e.key === 'Escape') closeLightbox();
            if (e.key === 'ArrowLeft') navigate(-1);
            if (e.key === 'ArrowRight') navigate(1);
        });

        // Init
        init();

    </script>
</body>

</html>