<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exposr</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow-x: hidden;
            overflow-y: scroll;
        }

        header {
            text-align: center;
            padding: 2.5rem 1rem;
            background: #0a0a0a;
            position: relative;
        }

        .logo {
            height: 23px;
            /* Smaller logo */
            width: auto;
            display: block;
            margin: 0 auto;
            opacity: 0.9;
        }

        .gallery {
            padding: 0 1rem;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            /* 3 Columns like reference */
            gap: 24px;
            grid-auto-rows: 20px;
            /* Base row height for masonry calculations */
            grid-auto-flow: dense;
            width: 100%;
            max-width: 1600px;
            /* Constrain width */
            margin: 0 auto;
            /* Center gallery */
        }

        @media (max-width: 1200px) {
            .gallery {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            .gallery {
                grid-template-columns: 1fr;
            }

            /* Force single column spans on mobile to prevent overflow/misalignment */
            .w-1,
            .w-2,
            .w-3 {
                grid-column: span 1 !important;
            }
        }

        .photo-item {
            position: relative;
            cursor: pointer;
            overflow: hidden;
            border-radius: 12px;
            /* Rounded corners */
            background: #111;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease, transform 0.6s ease;
            /* Removed content-visibility to prevent layout gaps with dense grid */
        }

        .photo-item.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .photo-item img {
            width: 100%;
            height: 100%;
            display: block;
            transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s;
            object-fit: cover;
            /* border-radius removed to let container clip */
            opacity: 0;
        }

        .photo-item img.loaded {
            opacity: 1;
        }

        .photo-item:hover img {
            transform: scale(1.03);
        }

        /* Grid Spans */
        .w-1 {
            grid-column: span 1;
        }

        .w-2 {
            grid-column: span 2;
        }

        .w-3 {
            grid-column: span 3;
        }



        .photo-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 2rem 1.5rem 1.5rem;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 0.9rem;
            /* Increased from 0.75rem */
            pointer-events: none;
        }

        .photo-item:hover .photo-info {
            opacity: 1;
        }

        .delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(2px);
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 1;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
        }



        .delete-btn:hover {
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border-color: rgba(255, 255, 255, 0.6);
        }

        .move-btn {
            position: absolute;
            top: 10px;
            right: 40px;
            /* To the left of delete btn */
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(2px);
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 1;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .move-btn:hover {
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            border-color: rgba(255, 255, 255, 0.6);
        }

        .photo-item:hover .delete-btn,
        .photo-item:hover .move-btn {
            opacity: 1;
        }

        .photo-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.2rem;
            letter-spacing: 0.02em;
        }

        .photo-date {
            font-size: 0.85rem;
            color: #ccc;
            margin-bottom: 0.2rem;
            font-weight: 500;
        }

        .info-line {
            line-height: 1.4;
            color: #aaa;
            font-weight: 400;
        }

        /* Lightbox */
        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--lightbox-bg);
            /* Updated to use theme variable */
            display: flex;
            /* keep flex, but we toggle visibility with class */
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .lightbox.active {
            opacity: 1;
            pointer-events: auto;
        }

        .lightbox-close {
            position: absolute;
            top: 1.5rem;
            right: 2rem;
            background: none;
            border: none;
            color: var(--lightbox-text);
            font-size: 2rem;
            cursor: pointer;
            z-index: 1010;
            opacity: 0.7;
            transition: opacity 0.2s, color 0.3s;
            padding: 10px;
        }

        .lightbox-close:hover {
            opacity: 1;
        }

        .lightbox-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--lightbox-arrow);
            font-size: 3rem;
            cursor: pointer;
            padding: 2rem;
            z-index: 1010;
            transition: color 0.2s;
        }

        .lightbox-arrow:hover {
            color: var(--lightbox-arrow-hover);
        }

        .arrow-prev {
            left: 0;
        }

        .arrow-next {
            right: 0;
        }

        .lightbox-content {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            overflow: hidden;
            padding-bottom: 2rem;
        }

        .lightbox-img-wrapper {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            overflow: hidden;
        }

        .lightbox-img-wrapper:active {
            cursor: grabbing;
        }

        .lightbox img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transform-origin: 0 0;
            will-change: transform;
            user-select: none;
        }

        .lightbox-overlay {
            position: relative;
            width: 100%;
            text-align: center;
            pointer-events: none;
            padding-top: 1rem;
            color: var(--lightbox-meta);
            flex-shrink: 0;
            left: auto;
            bottom: auto;
            transform: none;
            text-shadow: none;
        }

        .lightbox-title {
            font-size: 1rem;
            font-weight: 500;
            color: var(--lightbox-text);
        }

        .lightbox-meta {
            font-size: 0.8rem;
            color: var(--lightbox-meta);
            margin-top: 0.3rem;
        }

        .loading-sentinel {
            width: 100%;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            margin-top: 2rem;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 2px solid var(--spinner-border);
            border-top: 2px solid var(--spinner-active);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        :root {
            --bg-color: #0a0a0a;
            --text-color: #fff;
            --header-bg: rgba(0, 0, 0, 0.8);
            --header-bg-sticky: rgba(0, 0, 0, 0.95);
            --nav-text: #888;
            --nav-text-hover: #fff;
            --nav-separator: rgba(255, 255, 255, 0.4);
            --lightbox-bg: rgba(10, 10, 10, 0.98);
            --lightbox-text: #fff;
            --lightbox-arrow: rgba(255, 255, 255, 0.5);
            --lightbox-arrow-hover: #fff;
            --lightbox-meta: #aaa;
            --spinner-border: #333;
            --spinner-active: #fff;
        }

        body.light-mode {
            --bg-color: #f2f2f2;
            --text-color: #333;
            --header-bg: rgba(242, 242, 242, 0.8);
            --header-bg-sticky: rgba(242, 242, 242, 0.95);
            --nav-text: #666;
            --nav-text-hover: #000;
            --nav-separator: rgba(0, 0, 0, 0.2);
            --lightbox-bg: rgba(242, 242, 242, 0.98);
            --lightbox-text: #333;
            --lightbox-arrow: rgba(0, 0, 0, 0.5);
            --lightbox-arrow-hover: #000;
            --lightbox-meta: #666;
            --spinner-border: #ddd;
            --spinner-active: #666;
            --spinner-active: #666;
            --auth-bg: #fff;
            --auth-text: #333;
        }

        /* Auth Styles */
        .auth-box {
            background: var(--auth-bg);
            color: var(--auth-text);
            padding: 2rem;
            width: 100%;
            max-width: 320px;
            border-radius: 4px;
            text-align: center;
        }

        .auth-box h2 {
            margin-bottom: 1.5rem;
            font-weight: 500;
        }

        .auth-box input {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            background: transparent;
            color: inherit;
            font-family: inherit;
        }

        .auth-box button[type="submit"] {
            width: 100%;
            padding: 0.8rem;
            background: #000;
            color: #fff;
            border: none;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        body.light-mode .auth-box button[type="submit"] {
            background: #333;
        }

        .auth-switch {
            margin-top: 1rem;
            font-size: 0.85rem;
            color: #888;
        }

        #auth-switch-btn {
            background: none;
            border: none;
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            font-family: inherit;
            margin-left: 0.3rem;
        }

        .auth-error {
            color: red;
            font-size: 0.85rem;
            margin-top: 1rem;
            min-height: 1.2em;
        }

        /* User Menu Item */
        .nav-user {
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            color: var(--nav-text);
            margin-left: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-login-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--nav-text);
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.8rem;
        }

        .nav-login-btn:hover {
            color: var(--nav-text-hover);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow-x: hidden;
            overflow-y: scroll;
            transition: background 0.3s ease, color 0.3s ease;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Header & Nav */
        header {
            position: sticky;
            top: 0;
            z-index: 1000;
            padding: 2rem 0;
            /* Remove horizontal padding from header */
            background: var(--header-bg);
            backdrop-filter: blur(10px);
            transition: all 0.4s ease;
            width: 100%;
            box-sizing: border-box;
        }

        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1600px;
            /* Match gallery max-width */
            margin: 0 auto;
            padding: 0 2rem;
            /* Add horizontal padding here */
            box-sizing: border-box;
        }

        header.sticky {
            padding: 0.8rem 0;
            background: var(--header-bg-sticky);
        }

        header.sticky .logo-link {
            opacity: 0;
            pointer-events: none;
            max-width: 0;
            margin: 0;
        }

        .logo-link {
            order: 2;
            display: flex;
            align-items: center;
            text-decoration: none;
            transition: all 0.4s ease;
            max-width: 500px;
            /* Increased to fit full logo */
            overflow: hidden;
            white-space: nowrap;
        }

        .logo {
            height: 28px;
            width: auto;
            transition: all 0.4s ease;
        }

        /* Logo Theme Logic */
        .logo-light {
            display: none;
        }

        .logo-dark {
            display: block;
        }

        body.light-mode .logo-light {
            display: block;
        }

        body.light-mode .logo-dark {
            display: none;
        }

        .nav-wrapper {
            display: flex;
            align-items: center;
            flex: 1;
            order: 1;
            overflow: hidden;
            position: relative;
        }

        #main-nav {
            display: flex;
            gap: 15px;
            /* Reduced from 30px */
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            scroll-behavior: smooth;
            align-items: center;
        }

        #main-nav::-webkit-scrollbar {
            display: none;
        }

        .nav-item {
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            /* Tiny bit smaller */
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--nav-text);
            cursor: pointer;
            transition: color 0.3s ease;
            white-space: nowrap;
            padding: 0.5rem 0;
            user-select: none;

            /* Reset vertical/rotation properties */
            writing-mode: horizontal-tb;
            text-orientation: initial;
            transform: none;
        }

        .nav-item:hover,
        .nav-item.active {
            color: var(--nav-text-hover);
        }

        .nav-separator {
            width: 1px;
            height: 14px;
            background-color: var(--nav-separator);
            margin: 0 10px;
            /* Reduced from 15px */
            display: inline-block;
            vertical-align: middle;
        }

        /* Theme Toggle */
        .theme-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem 0;
            color: var(--nav-text);
            transition: color 0.3s ease;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .theme-toggle:hover {
            color: var(--nav-text-hover);
        }

        .mobile-upload-btn,
        .mobile-menu-btn,
        .mobile-menu-overlay {
            display: none;
            /* Hidden on desktop */
        }

        .nav-upload-btn {
            background: #fff;
            color: #000;
            border: 1px solid #fff;
            padding: 0.5rem 1.2rem;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 15px;
        }

        .nav-upload-btn:hover {
            background: transparent;
            color: #fff;
        }

        body.light-mode .nav-upload-btn {
            background: #000;
            color: #fff;
            border-color: #000;
        }

        body.light-mode .nav-upload-btn:hover {
            background: transparent;
            color: #000;
        }

        .nav-arrow {
            display: none;
        }

        /* Mobile Navigation */
        @media (max-width: 600px) {
            header {
                padding: 1rem 0;
                position: sticky;
                top: 0;
                z-index: 1000;
                transition: transform 0.3s ease-in-out;
            }

            header.header-hidden {
                transform: translateY(-100%);
            }

            .header-container {
                flex-direction: row;
                /* Keep row for 3 items */
                justify-content: space-between;
                align-items: center;
                gap: 1rem;
                padding: 0 20px;
                position: relative;
            }

            /* Mobile Buttons */
            .mobile-menu-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                background: none;
                border: none;
                font-size: 1.2rem;
                /* Reduced from 1.5rem */
                color: var(--nav-text);
                cursor: pointer;
                z-index: 101;
                /* Above menus */
                padding: 0;
            }

            .mobile-menu-btn.left {
                order: 1;
            }

            .logo-link {
                order: 2;
                margin: 0;
                flex: 1;
                text-align: center;
                display: flex;
                justify-content: center;
            }

            .mobile-user-display {
                order: 3;
                font-family: 'Outfit', sans-serif;
                font-size: 0.9rem;
                color: var(--nav-text);
                min-width: 40px;
                /* Balance left btn */
                text-align: right;
            }

            /* Hide Desktop Nav Wrapper */
            .header-container .nav-wrapper {
                display: none !important;
            }

            /* Logo adjustments */
            .logo {
                height: 16px;
                /* Reduced from 20px */
            }

            /* Mobile Menu Overlays */
            .mobile-menu-overlay {
                position: fixed;
                top: 0;
                bottom: 0;
                width: 250px;
                background: var(--bg-color);
                z-index: 100;
                padding: 80px 20px 20px 20px;
                transition: transform 0.3s ease;
                display: flex;
                flex-direction: column;
                border: 1px solid var(--nav-separator);
                left: 0;
                transform: translateX(-100%);
                border-right: 1px solid rgba(255, 255, 255, 0.1);
            }

            .mobile-menu-overlay.right {
                right: 0;
                transform: translateX(100%);
                border-left: 1px solid rgba(255, 255, 255, 0.1);
            }

            .mobile-menu-overlay.active {
                transform: translateX(0);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            }

            /* Menu Content */
            .menu-content {
                display: flex;
                flex-direction: column;
                gap: 20px;
            }

            .menu-content .nav-item {
                font-size: 1.2rem;
                padding: 10px 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            }

            .close-menu-btn {
                position: absolute;
                top: 20px;
                right: 20px;
                /* Used for Left menu too? Usually Close is top right or top left opposite side */
                /* Let's replicate header btn position or just top right of container */
                background: none;
                border: none;
                color: var(--nav-text);
                font-size: 2rem;
                cursor: pointer;
            }

            .mobile-menu-overlay.left .close-menu-btn {
                right: 20px;
            }

            .mobile-menu-overlay.right .close-menu-btn {
                left: 20px;
                right: auto;
            }

            /* Theme Toggle Mobile */
            .theme-toggle-mobile {
                background: none;
                border: 1px solid var(--nav-text);
                color: var(--nav-text);
                padding: 10px;
                width: 100%;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                margin-top: 10px;
                cursor: pointer;
            }

            .mobile-upload-only {
                display: block !important;
                background: var(--text-color);
                color: var(--bg-color);
                border: 1px solid var(--text-color);
                margin: 0;
                text-align: center;
            }

            /* Auth overrides */
            #mobile-auth-container .auth-user-display {
                font-size: 1rem;
                margin-bottom: 1rem;
                text-align: center;
                display: block;
            }

            #mobile-auth-container .login-trigger-btn {
                width: 100%;
                padding: 10px;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid var(--nav-text);
                color: var(--nav-text);
                text-align: center;
                display: block;
            }

            .logo-link {
                order: 1;
                margin-bottom: 0.5rem;
                display: block;
                /* Ensure it behaves as block for centering if needed */
                max-width: none;
                /* Reset desktop constraint */
                max-height: 100px;
                /* For smooth mobile transition */
            }

            .logo {
                height: 24px;
                /* Removed overrides */
                transition: all 0.4s ease;
            }

            header.sticky .logo-link {
                max-height: 0;
                margin: 0;
                opacity: 0;
                pointer-events: none;
            }

            .nav-wrapper {
                order: 2;
                width: 100%;
                justify-content: flex-start;
                /* Left align wrapper */
                /* Fade only on right side */
                -webkit-mask-image: linear-gradient(90deg, #000 0%, #000 85%, transparent);
                mask-image: linear-gradient(90deg, #000 0%, #000 85%, transparent);
            }

            #main-nav {
                width: 100%;
                gap: 20px;
                padding: 0 20px 0 0;
                /* Padding only on right for fade */
                justify-content: flex-start;
                /* Prevent cropping on left */
            }

            /* Allow scrolling if content overflows */
            #main-nav {
                /* For centering to work when wrapping isn't enabled, we need to be careful.
                   With overflow-x: auto and flex, justify-content: center will clip start if overflowing.
                   Safe way: use margin: auto on items or just accept start alignment if overflow.
                   BUT user specifically said "centered". Usually means visual center. 
                   If items fit, they are centered. If they don't, they are scrollable.
                   A common trick: margin: 0 auto; on the flex container logic? No. 
                   Let's stick to justify-content: center, but note the clipping risk. 
                   Wait, `safe center` value exists but unrelated support.
                   
                   Alternative: Use ::before and ::after spacers?
                   
                   Let's try justify-content: center. If the list is huge, the first items might be inaccessible.
                   However, we only have a few collections usually. "only 2-3 are shown at a time".
                   So it WILL overflow. 
                   
                   If it overflows, we MUST NOT use justify-content: center (unsafe).
                   We should use justify-content: flex-start.
                   
                   BUT user said "mobile that menu should be centered". 
                   Maybe they mean the *container* is centered in the screen (it is).
                   Or the active item is centered?
                   
                   "horizontally scrollable so only 2-3 are shown at a time"
                   
                   Let's set `justify-content: flex-start` but add padding to pseudo-center?
                   
                   Actually, let's keep `justify-content: center` for now? No, checking standard practice.
                   If it scrolls, `flex-start` is best. 
                   To make it look centered when few items: `margin: 0 auto`.
                   
                   Let's try `justify-content: center`. If user has many collections, I might need to fix. 
                   Given currently only 1 collection + home = 2 items. They will fit. 
                   So center is fine.
                */
            }

            .nav-arrow {
                display: none;
                /* Left align wrapper */
                /* Fade only on right side */
                -webkit-mask-image: linear-gradient(90deg, #000 0%, #000 85%, transparent);
                mask-image: linear-gradient(90deg, #000 0%, #000 85%, transparent);
            }

            .mobile-upload-btn {
                display: block;
                order: 2;
                /* After logo (1), before nav (3) */
                width: 100%;
                /* Own line, full width */
                margin: 0;
                text-align: center;
                transition: all 0.4s ease;
                background: var(--text-color);
                /* Inverse */
                color: var(--bg-color);
                /* Inverse */
                border-color: var(--text-color);
            }

            .mobile-upload-btn:hover {
                background: transparent;
                color: var(--text-color);
            }

            /* Hide desktop button on mobile */
            .nav-wrapper .nav-upload-btn {
                display: none;
            }

            /* Sticky Hiding for Mobile Upload Btn */
            header.sticky .mobile-upload-btn {
                max-height: 0;
                margin: 0;
                padding: 0;
                border: 0;
                opacity: 0;
                pointer-events: none;
                overflow: hidden;
            }

            #main-nav {
                width: 100%;
                gap: 20px;
                padding: 0 20px 0 0;
                /* Padding only on right for fade */
                justify-content: flex-start;
                /* Prevent cropping on left */
            }

            /* Update orders for correct flow */
            .logo-link {
                order: 1;
            }

            .mobile-upload-btn {
                display: none;
                /* Default hidden */
                order: 2;
                margin-bottom: 0.5rem;
            }

            /* Only show if admin */
            body.is-admin .mobile-upload-btn {
                display: block;
            }

            .nav-wrapper {
                order: 3;
            }

            .nav-arrow {
                display: none;
                /* Hide arrows on mobile as requested */
            }

            /* Auth Box Mobile overrides */
            .auth-box {
                width: 90%;
            }
        }
    </style>
</head>

<body>
    <header id="main-header">
        <div class="header-container">
            <!-- Mobile Controls -->
            <button class="mobile-menu-btn left" onclick="toggleMobileMenu('left')">☰</button>

            <a href="About.html" class="logo-link">
                <img src="Website assets/exposr_name.svg" alt="exposr" class="logo logo-dark">
                <img src="Website assets/exposr_name - forLightBG.svg" alt="exposr" class="logo logo-light">
            </a>

            <!-- Mobile User Display (Right Side) -->
            <div class="mobile-user-display" id="mobile-user-display"></div>

            <!-- Desktop Nav Wrapper -->
            <div class="nav-wrapper">
                <button class="nav-arrow nav-arrow-left" onclick="scrollNav(-1)">‹</button>
                <nav id="main-nav"></nav>
                <button class="nav-arrow nav-arrow-right" onclick="scrollNav(1)">›</button>
            </div>
        </div>
    </header>

    <!-- Mobile Menus -->
    <div id="mobile-menu-left" class="mobile-menu-overlay left">
        <button class="close-menu-btn" onclick="toggleMobileMenu('left')">×</button>
        <div class="menu-content" id="mobile-menu-content">
            <!-- All Content injected here -->
        </div>
    </div>

    <div class="gallery" id="gallery"></div>
    <div class="loading-sentinel" id="sentinel">
        <div class="spinner"></div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <button class="lightbox-close" onclick="closeLightbox()">×</button>
        <button class="lightbox-arrow arrow-prev" onclick="navigate(-1)">‹</button>
        <button class="lightbox-arrow arrow-next" onclick="navigate(1)">›</button>

        <div class="lightbox-content">
            <div class="lightbox-img-wrapper" id="zoom-container">
                <img id="lightbox-img" src="" alt="">
            </div>
            <div class="lightbox-overlay" id="lightbox-info"></div>
        </div>
    </div>

    <!-- Login / Signup Modal -->
    <div class="lightbox" id="auth-modal">
        <button class="lightbox-close" onclick="closeAuthModal()">×</button>
        <div class="auth-box">
            <h2 id="auth-title">Login</h2>
            <form id="auth-form" onsubmit="handleAuth(event)">
                <input type="text" id="auth-username" placeholder="Username" required>
                <input type="password" id="auth-password" placeholder="Password" required>
                <button type="submit" id="auth-submit">Login</button>
            </form>
            <div class="auth-switch">
                <span id="auth-switch-text">New here?</span>
                <button onclick="toggleAuthMode()" id="auth-switch-btn">Sign Up</button>
            </div>
            <div id="auth-error" class="auth-error"></div>
        </div>
    </div>

    <!-- Upload Modal -->
    <div class="lightbox" id="upload-modal">
        <div class="auth-box">
            <button class="lightbox-close" style="position: absolute; top: 10px; right: 10px;"
                onclick="closeUploadModal()">×</button>
            <h2>Upload Photo</h2>
            <form id="upload-form" onsubmit="handleUploadSubmit(event)">
                <!-- File Input -->
                <div style="margin-bottom: 1rem;">
                    <label for="file-upload"
                        style="display:block; margin-bottom:0.5rem; text-align:left; color:#ccc;">Choose Photo:</label>
                    <input type="file" id="file-upload" accept="image/*" required
                        style="width: 100%; padding: 0.5rem; background: rgba(255,255,255,0.1); color: white; border: 1px solid #444;">
                </div>

                <!-- Collection Selector -->
                <div style="margin-bottom: 1rem;">
                    <label for="collection-select"
                        style="display:block; margin-bottom:0.5rem; text-align:left; color:#ccc;">Collection:</label>
                    <select id="collection-select" onchange="toggleNewCollectionInput()"
                        style="width: 100%; padding: 0.8rem; background: #222; color: white; border: 1px solid #444; border-radius: 4px;">
                        <option value="home">Home (Root)</option>
                        <!-- Collections injected via JS -->
                        <option value="new">+ Create New Collection</option>
                    </select>
                </div>

                <!-- New Collection Name (Hidden by default) -->
                <div id="new-collection-div" style="margin-bottom: 1rem; display: none;">
                    <label for="new-collection-name"
                        style="display:block; margin-bottom:0.5rem; text-align:left; color:#ccc;">New Collection
                        Name:</label>
                    <input type="text" id="new-collection-name" placeholder="e.g. Summer 2024"
                        style="width: 100%; padding: 0.8rem; background: #222; color: white; border: 1px solid #444; border-radius: 4px;">
                </div>

                <div id="upload-status" style="margin-bottom: 1rem; font-size: 0.9rem;"></div>
                <button type="submit" id="upload-submit-btn"
                    style="width:100%; padding: 0.8rem; background:white; color:black; border:none; border-radius:4px; font-weight:bold; cursor:pointer;">Upload</button>
            </form>
        </div>
    </div>

    <!-- Move Modal -->
    <div class="lightbox" id="move-modal">
        <div class="auth-box">
            <button class="lightbox-close" style="position: absolute; top: 10px; right: 10px;"
                onclick="closeMoveModal()">×</button>
            <h2>Move Photo</h2>
            <p id="move-filename" style="margin-bottom: 1rem; color: #ccc; font-size: 0.9rem;"></p>
            <form id="move-form" onsubmit="handleMoveSubmit(event)">

                <!-- Collection Selector -->
                <div style="margin-bottom: 1rem;">
                    <label for="move-collection-select"
                        style="display:block; margin-bottom:0.5rem; text-align:left; color:#ccc;">Move to
                        Collection:</label>
                    <select id="move-collection-select"
                        style="width: 100%; padding: 0.8rem; background: #222; color: white; border: 1px solid #444; border-radius: 4px;">
                        <option value="home">Home (Root)</option>
                        <!-- Collections injected via JS -->
                    </select>
                </div>

                <div id="move-status" style="margin-bottom: 1rem; font-size: 0.9rem;"></div>
                <button type="submit" id="move-submit-btn"
                    style="width:100%; padding: 0.8rem; background:white; color:black; border:none; border-radius:4px; font-weight:bold; cursor:pointer;">Move
                    Photo</button>
            </form>
        </div>
    </div>

    <script>
        // State
        const state = {
            homePhotos: [],
            collections: {},
            currentPhotos: [], // The array currently being displayed
            loadedCount: 0,
            batchSize: 24,
            isLoading: false
        };

        const zoom = {
            scale: 1,
            panning: false,
            pointX: 0,
            pointY: 0,
            startX: 0,
            startY: 0
        };

        // Utility: Fisher-Yates Shuffle
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // DOM Elements
        const gallery = document.getElementById('gallery');
        const sentinel = document.getElementById('sentinel');
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = document.getElementById('lightbox-img');
        const zoomContainer = document.getElementById('zoom-container');

        // Initialize
        async function init() {
            try {
                const response = await fetch('photos.json');
                const data = await response.json();

                // Handle new data structure
                state.homePhotos = data.home || [];
                state.collections = data.collections || {};

                // Shuffle everything
                shuffleArray(state.homePhotos);
                for (const key in state.collections) {
                    shuffleArray(state.collections[key]);
                }

                // Default to Home
                switchCollection('Home');

                // Init Theme
                initTheme();

                // Render Sidebar (renamed)
                renderNav();

                // Setup Infinite Scroll
                const observer = new IntersectionObserver((entries) => {
                    if (entries[0].isIntersecting && !state.isLoading) {
                        loadMorePhotos();
                    }
                }, { rootMargin: '200px' });

                observer.observe(sentinel);

            } catch (error) {
                console.error('Failed to load photos:', error);
                sentinel.innerHTML = 'Error loading photos.';
            }
        }

        function switchCollection(name) {
            // Update State
            if (name === 'Home') {
                state.currentPhotos = state.homePhotos;
            } else {
                state.currentPhotos = state.collections[name];
            }

            state.loadedCount = 0;
            state.isLoading = false;

            // Allow re-triggering sentinel
            sentinel.style.display = 'flex';
            sentinel.innerHTML = '<div class="spinner"></div>';

            // Clear Grid
            gallery.innerHTML = '';

            // Load initial batch
            if (state.currentPhotos.length === 0) {
                sentinel.innerHTML = 'No photos found.';
            } else {
                loadMorePhotos();

                // Re-observe sentinel if it was disconnected or hidden
                // (Observer usually stays active on element, but we ensure display is flex)
            }
        }

        function loadMorePhotos() {
            if (state.loadedCount >= state.currentPhotos.length) {
                sentinel.style.display = 'none';
                return;
            }

            state.isLoading = true;
            const batch = state.currentPhotos.slice(state.loadedCount, state.loadedCount + state.batchSize);

            batch.forEach((photo, i) => {
                const globalIndex = state.loadedCount + i;
                createPhotoElement(photo, globalIndex);
            });

            state.loadedCount += batch.length;
            state.isLoading = false;
        }

        // Helper to format metadata from JSON
        function formatMetadata(exif) {
            if (!exif) return { title: '', details: '', date: '', html: '' };

            const model = exif.model || exif.make || '';
            const lens = exif.lens || '';
            const title = model ? model + (lens ? ` + ${lens}` : '') : '';

            const details = [];
            if (exif.focal_length) details.push(`${exif.focal_length}mm`);
            if (exif.f_number) details.push(`f/${exif.f_number}`);
            if (exif.exposure_time) details.push(`${exif.exposure_time}s`);
            if (exif.iso) details.push(`ISO ${exif.iso}`);
            if (exif.ev && exif.ev != '0' && exif.ev != 0) {
                const val = parseFloat(exif.ev);
                const sign = val > 0 ? '+' : '';
                details.push(`${sign}${val} EV`);
            }

            const detailsStr = details.join(' · ');
            const dateStr = exif.date ? exif.date.replace(/:/g, '-').replace(' ', ' ').substring(0, 16) : ''; // Simple formatting

            return {
                title: title,
                details: detailsStr,
                date: dateStr,
                html: `
                    ${title ? `<div class="photo-title">${title}</div>` : ''}
                    ${dateStr ? `<div class="photo-date">${dateStr}</div>` : ''}
                    <div class="info-line">${detailsStr}</div>
                `
            };
        }

        function createPhotoElement(photo, index) {
            const item = document.createElement('div');
            item.className = 'photo-item';

            // Check Admin for Actions
            const user = getUser();
            if (user && user.role === 'admin') {
                // Delete Button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerText = '×';
                deleteBtn.title = 'Delete Photo';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deletePhoto(photo.filename, item);
                };
                item.appendChild(deleteBtn);

                // Move Button
                const moveBtn = document.createElement('button');
                moveBtn.className = 'move-btn';
                moveBtn.innerText = '⇄'; // Arrow symbol
                moveBtn.title = 'Move Photo';
                moveBtn.onclick = (e) => {
                    e.stopPropagation();
                    openMoveModal(photo.filename);
                };
                item.appendChild(moveBtn);
            }

            const img = document.createElement('img');
            // Use Thumbnail for grid
            if (photo.thumbnail && (photo.thumbnail.startsWith('blob:') || photo.thumbnail.startsWith('http'))) {
                img.src = photo.thumbnail;
                img.dataset.fullSrc = photo.thumbnail; // Use same blob for lightbox
            } else {
                img.src = `Photos/${photo.thumbnail}`;
                img.dataset.fullSrc = `Photos/${photo.filename}`;
            }
            img.loading = 'lazy';

            // Pre-calculate metadata from JSON
            const meta = formatMetadata(photo.exif);

            // Store metadata for lightbox
            img.dataset.metaTitle = meta.title;
            img.dataset.metaDetails = meta.details;
            img.dataset.metaDate = meta.date;

            const info = document.createElement('div');
            info.className = 'photo-info';
            info.innerHTML = meta.html;

            // Wait for image dimensions to determine grid span
            img.onload = function () {
                img.classList.add('loaded');
                item.classList.add('visible');

                const ratio = this.naturalWidth / this.naturalHeight;
                assignGridSpan(item, ratio);
            };

            item.appendChild(img);
            item.appendChild(info);
            item.onclick = () => openLightbox(index);
            gallery.appendChild(item);
        }

        function assignGridSpan(element, ratio) {
            // Store ratio for potential resize recalculations
            element.dataset.ratio = ratio;

            // 1. Assign Width randomly (keep variety) if not already assigned
            // We check if it has a width class? No, just overwrite or set.
            // But we should only set w-class once to avoid jumping on resize.
            // Check if w-1 or w-2 is present?
            let hasWidth = element.classList.contains('w-1') || element.classList.contains('w-2');

            if (!hasWidth) {
                const rand = Math.random();
                element.classList.remove('h-1', 'h-2'); // clear previous

                if (ratio > 1.5) {
                    // Panoramic / Wide Landscape
                    if (rand > 0.85) { element.classList.add('w-2'); } // Wide (Very rare: 15% chance only for very wide shots)
                    else { element.classList.add('w-1'); } // Regular
                } else {
                    // Everyone else (Standard Landscape, Square, Portrait)
                    // Strict w-1 to ensure grid holes are always fillable
                    element.classList.add('w-1');
                }
            }

            // 2. Calculate Row Span
            const width = element.offsetWidth;
            if (width > 0) {
                let finalRatio = ratio;

                // Randomize Aspect Ratio (Desktop Only)
                // User Request: "randomize the aspect ratios... (don't crop too much over 25%)"
                if (window.innerWidth > 600) {
                    // Check if we already have a random factor assigned
                    if (!element.dataset.heightVariance) {
                        // Generate random factor between 0.75 and 1.25 (+/- 25%)
                        element.dataset.heightVariance = (Math.random() * 0.5) + 0.75;
                    }
                    finalRatio = ratio / parseFloat(element.dataset.heightVariance);
                }

                const targetHeight = width / finalRatio;
                const rowHeight = 20; // Matches CSS grid-auto-rows
                const gap = 24;       // Matches CSS gap

                // span = (height + gap) / (rowHeight + gap)
                const rowSpan = Math.ceil((targetHeight + gap) / (rowHeight + gap));
                element.style.gridRowEnd = `span ${rowSpan}`;
            }
        }

        // recalculate on resize
        window.addEventListener('resize', () => {
            const items = document.querySelectorAll('.photo-item');
            items.forEach(item => {
                if (item.dataset.ratio) {
                    assignGridSpan(item, parseFloat(item.dataset.ratio));
                }
            });
        });

        function extractExifInfo(exif) {
            const title = exif.ImageDescription || '';
            const details = [];

            // Camera Model
            if (exif.Model) details.push(exif.Model);

            // Lens (check LensModel and Lens)
            if (exif.LensModel) details.push(exif.LensModel);
            else if (exif.Lens) details.push(exif.Lens);

            // Focal Length (standard or 35mm equiv)
            if (exif.FocalLength) {
                details.push(`${Math.round(Number(exif.FocalLength))}mm`);
            } else if (exif.FocalLengthIn35mmFilm) {
                details.push(`${exif.FocalLengthIn35mmFilm}mm`);
            }

            // Aperture
            if (exif.FNumber) details.push(`f/${exif.FNumber}`);

            // Shutter Speed
            if (exif.ExposureTime) {
                const t = exif.ExposureTime;
                details.push(t < 1 ? `1/${Math.round(1 / t)}s` : `${t}s`);
            }

            // ISO
            if (exif.ISOSpeedRatings) details.push(`ISO ${exif.ISOSpeedRatings}`);

            // EV (Robust check)
            if (exif.ExposureBiasValue !== undefined && exif.ExposureBiasValue !== null) {
                const ev = Number(exif.ExposureBiasValue);
                if (!isNaN(ev)) {
                    const sign = ev > 0 ? '+' : '';
                    details.push(`${sign}${ev.toFixed(1)} EV`);
                }
            }

            const detailsStr = details.join(' · ');

            // Parsing Date Time Original
            let dateStr = '';
            if (exif.DateTimeOriginal) {
                const match = exif.DateTimeOriginal.match(/^(\d{4}):(\d{2}):(\d{2})\s(\d{2}):(\d{2})/);
                if (match) {
                    dateStr = `${match[1]}-${match[2]}-${match[3]} ${match[4]}:${match[5]}`;
                } else {
                    dateStr = exif.DateTimeOriginal;
                }
            }

            return {
                title: title,
                details: detailsStr,
                date: dateStr,
                html: `
                    ${title ? `<div class="photo-title">${title}</div>` : ''}
                    ${dateStr ? `<div class="photo-date">${dateStr}</div>` : ''}
                    <div class="info-line">${detailsStr}</div>
                `
            };
        }

        // --- Lightbox Logic ---

        function openLightbox(index) {
            state.currentIndex = index;
            updateLightboxContent();
            lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeLightbox() {
            lightbox.classList.remove('active');
            document.body.style.overflow = 'auto'; // restore scroll
            resetZoom();
        }

        function navigate(dir) {
            // Find actual number of loaded items to avoid bounds error if we clicked a not-yet-loaded index?
            // Actually relying on DOM elements for source is safer.
            const items = document.querySelectorAll('.photo-item img');
            state.currentIndex = (state.currentIndex + dir + items.length) % items.length;
            updateLightboxContent();
        }

        function updateLightboxContent() {
            const items = document.querySelectorAll('.photo-item img');
            const targetImg = items[state.currentIndex];

            if (!targetImg) return;

            lightboxImg.src = targetImg.dataset.fullSrc || targetImg.src;

            const infoBox = document.getElementById('lightbox-info');
            const title = targetImg.dataset.metaTitle || '';
            const details = targetImg.dataset.metaDetails || '';
            const date = targetImg.dataset.metaDate || '';

            infoBox.innerHTML = `
                ${title ? `<div class="lightbox-title">${title}</div>` : ''}
                <div class="lightbox-meta">
                    ${date ? `<span>${date}</span>` : ''}
                    ${date && details ? ' · ' : ''}
                    ${details}
                </div>
            `;

            resetZoom();
        }

        // --- Zoom & Pan Logic (Cursor Centered) ---

        function resetZoom() {
            zoom.scale = 1;
            zoom.pointX = 0;
            zoom.pointY = 0;
            applyTransform();
        }

        function applyTransform() {
            lightboxImg.style.transform = `translate(${zoom.pointX}px, ${zoom.pointY}px) scale(${zoom.scale})`;
        }

        zoomContainer.addEventListener('wheel', (e) => {
            e.preventDefault();

            // 1. Get mouse position relative to the image container
            const rect = zoomContainer.getBoundingClientRect();
            // We want the position relative to the center of the viewport/container because our transform origin is not set to 0 0 in CSS?
            // Wait, in CSS I set transform-origin: 0 0; 
            // This simplifies math: everything starts at top-left.
            // Actually, centering the image is done by flexbox.
            // Let's use the image's own rect.

            const imgRect = lightboxImg.getBoundingClientRect();

            // Mouse position relative to the image's current top-left
            const mouseX = e.clientX - imgRect.left;
            const mouseY = e.clientY - imgRect.top;

            // Determine new scale
            const delta = -Math.sign(e.deltaY) * 0.5;
            const newScale = Math.min(Math.max(1, zoom.scale + delta), 5);

            if (newScale === zoom.scale) return; // No change

            // 2. Adjust translation
            // Logic: The point under the mouse (mouseX, mouseY) should remain at the same screen coordinate.
            // (mouseX / oldScale) = "original pixel x"
            // We want (original pixel x) * newScale + newTranslateX = ScreenX (where ScreenX is e.clientX - container.left?? No.)

            // Standard Zoom-at-point algorithm:
            // translate -= (mouseX / scale) * (newScale - scale)
            // But we need to account for our specific transform setup.

            // Let's do it relative to the current translation (zoom.pointX/Y).
            // The coordinate in "unscaled local space" is:
            // localX = (e.clientX - (containerRect.left + containerWidth/2 - imgWidth/2) - currentTranslateX) / currentScale
            // This is getting complicated because of Flex centering.

            /* Simplified Approach that works robustly with transform-origin: 0 0 */
            /* We need to track the "virtual" top-left corner */

            const contentRect = zoomContainer.getBoundingClientRect();
            // Calculate mouse offset from the content center (where image is centered broadly) is not enough.

            // Let's stick to the relative shift.
            // The mouse is at `e.clientX`, `e.clientY`.
            // The image is currently at `imgRect.left`, `imgRect.top`.
            // The point clicked on the image is `ptrX = (e.clientX - imgRect.left) / zoom.scale`.

            // After scaling, we want that same point `ptrX` to be at `e.clientX`.
            // So: `imgNewLeft + ptrX * newScale = e.clientX`
            // `imgNewLeft = e.clientX - ptrX * newScale`

            // We control `zoom.pointX/Y`. 
            // Note: `imgRect.left` includes the flexbox centering offset! 
            // We can't easily control that via `translate`.
            // BUT: `transform` is applied *after* layout.
            // If `transform-origin` is `0 0`, the transform applies to the top-left of the element.
            // The element is centered by flex.

            // Let MainOffset be the offset of the image top-left from window 0,0 when scale=1, translate=0.
            // We can calculate BaseX = imgRect.left - zoom.pointX.

            const BaseX = imgRect.left - zoom.pointX;
            const BaseY = imgRect.top - zoom.pointY;

            const ptrX = (e.clientX - imgRect.left) / zoom.scale;
            const ptrY = (e.clientY - imgRect.top) / zoom.scale;

            zoom.scale = newScale;

            // New position (left/top)
            // NewLeft = BaseX + newTranslateX
            // We want: NewLeft + ptrX * newScale = e.clientX
            // BaseX + newTranslateX + ptrX * newScale = e.clientX
            // newTranslateX = e.clientX - BaseX - ptrX * newScale

            zoom.pointX = e.clientX - BaseX - (ptrX * newScale);
            zoom.pointY = e.clientY - BaseY - (ptrY * newScale);

            applyTransform();
        });

        // Pan Support
        zoomContainer.addEventListener('mousedown', (e) => {
            if (zoom.scale <= 1) return;
            e.preventDefault();
            zoom.panning = true;
            zoom.startX = e.clientX - zoom.pointX;
            zoom.startY = e.clientY - zoom.pointY;
        });

        document.addEventListener('mousemove', (e) => {
            if (!zoom.panning) return;
            e.preventDefault();
            zoom.pointX = e.clientX - zoom.startX;
            zoom.pointY = e.clientY - zoom.startY;
            applyTransform();
        });

        document.addEventListener('mouseup', () => {
            zoom.panning = false;
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (!lightbox.classList.contains('active')) return;
            if (e.key === 'Escape') closeLightbox();
            if (e.key === 'ArrowLeft') navigate(-1);
            if (e.key === 'ArrowRight') navigate(1);
        });

        // Initialize
        init();
        initTheme();

        // Theme Logic
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
            }
        }

        function toggleTheme() {
            const isLight = document.body.classList.toggle('light-mode');
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
            renderNav(); // Re-render to update icon
        }

        /* New Logic */

        // Sticky Header Logic (Desktop/General)
        const header = document.getElementById('main-header');
        window.addEventListener('scroll', () => {
            // Sticky background effect
            if (window.scrollY > 50) {
                header.classList.add('sticky');
            } else {
                header.classList.remove('sticky');
            }
        });

        // Mobile Nav Scroll Logic
        function scrollNav(direction) {
            const nav = document.getElementById('main-nav');
            const scrollAmount = 150; // Approx width of items
            nav.scrollBy({ left: direction * scrollAmount, behavior: 'smooth' });
        }

        function renderNav() {
            const nav = document.getElementById('main-nav');

            // Sync Mobile Menus
            renderMobileMenus();

            if (!nav) return;

            nav.innerHTML = '';

            const createItem = (label, isActive = false) => {
                const item = document.createElement('div');
                item.className = 'nav-item';
                if (isActive) item.classList.add('active');
                item.innerText = label;
                item.onclick = () => {
                    document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');
                    switchCollection(label);
                };
                return item;
            };

            // Upload Button (Only if Admin)
            const user = getUser();
            if (user && user.role === 'admin') {
                const uploadBtn = document.createElement('button');
                uploadBtn.className = 'nav-upload-btn';
                uploadBtn.innerText = 'Upload';
                uploadBtn.onclick = triggerUpload;

                // Add to start of nav
                nav.appendChild(uploadBtn);

                // Add Separator after upload button
                const sep = document.createElement('div');
                sep.className = 'nav-separator';
                nav.appendChild(sep);

                // Show Mobile Upload Btn
                document.body.classList.add('is-admin');
            } else {
                document.body.classList.remove('is-admin');
            }

            nav.appendChild(createItem('Home', true));

            Object.keys(state.collections).forEach(name => {
                nav.appendChild(createItem(name));
            });

            // Add Separator
            const separator = document.createElement('div');
            separator.className = 'nav-separator';
            nav.appendChild(separator);

            // Theme Toggle
            const isLight = document.body.classList.contains('light-mode');
            const toggle = document.createElement('button');
            toggle.className = 'theme-toggle';
            toggle.onclick = toggleTheme;

            // Text instead of Icon
            toggle.innerText = "Light/Dark";
            toggle.title = isLight ? "Switch to Dark Mode" : "Switch to Light Mode";
            nav.appendChild(toggle);

            // User / Login
            const userDiv = document.createElement('div');
            userDiv.className = 'nav-user';

            if (user) {
                userDiv.innerHTML = `
                    <button class="nav-login-btn" onclick="logout()">Logout</button>
                `;
            } else {
                userDiv.innerHTML = `<button class="nav-login-btn" onclick="openAuthModal()">Login</button>`;
            }
            nav.appendChild(userDiv);
        }

        // --- Auth Logic ---
        let authMode = 'login'; // 'login' or 'signup'

        function getUser() {
            try {
                const u = localStorage.getItem('user');
                return u ? JSON.parse(u) : null;
            } catch (e) { return null; }
        }

        function openAuthModal() {
            document.getElementById('auth-modal').classList.add('active');
            resetAuthForm();
        }

        function closeAuthModal() {
            document.getElementById('auth-modal').classList.remove('active');
        }

        function toggleAuthMode() {
            authMode = authMode === 'login' ? 'signup' : 'login';
            resetAuthForm();
        }

        function resetAuthForm() {
            const title = document.getElementById('auth-title');
            const submit = document.getElementById('auth-submit');
            const switchText = document.getElementById('auth-switch-text');
            const switchBtn = document.getElementById('auth-switch-btn');
            const error = document.getElementById('auth-error');

            error.innerText = '';
            document.getElementById('auth-form').reset();

            if (authMode === 'login') {
                title.innerText = 'Login';
                submit.innerText = 'Login';
                switchText.innerText = 'New here?';
                switchBtn.innerText = 'Sign Up';
            } else {
                title.innerText = 'Sign Up';
                submit.innerText = 'Sign Up';
                switchText.innerText = 'Already have an account?';
                switchBtn.innerText = 'Login';
            }
        }

        async function handleAuth(e) {
            e.preventDefault();
            const username = document.getElementById('auth-username').value;
            const password = document.getElementById('auth-password').value;
            const errorDiv = document.getElementById('auth-error');
            const btn = document.getElementById('auth-submit');

            errorDiv.innerText = '';
            btn.disabled = true;

            const endpoint = authMode === 'login' ? '/.netlify/functions/login' : '/.netlify/functions/signup';

            try {
                const res = await fetch(endpoint, {
                    method: 'POST',
                    body: JSON.stringify({ username, password })
                });
                const data = await res.json();

                if (res.ok) {
                    if (authMode === 'signup') {
                        // Switch to login
                        authMode = 'login';
                        resetAuthForm();
                        errorDiv.style.color = 'green';
                        errorDiv.innerText = "Signup success! Please login.";
                    } else {
                        // Login Success
                        localStorage.setItem('user', JSON.stringify({
                            username: data.username,
                            role: data.role,
                            token: data.token
                        }));
                        closeAuthModal();
                        renderNav(); // Update UI
                    }
                } else {
                    errorDiv.style.color = 'red';
                    errorDiv.innerText = data.error || 'Request failed';
                }
            } catch (err) {
                errorDiv.innerText = 'Network Error';
            } finally {
                btn.disabled = false;
            }
        }

        function logout() {
            localStorage.removeItem('user');
            renderNav();
        }


        // --- Upload Logic ---
        function triggerUpload() {
            // Check auth again
            const user = getUser();
            if (!user || user.role !== 'admin') {
                alert("Unauthorized");
                return;
            }

            openUploadModal();
        }

        function openUploadModal() {
            const modal = document.getElementById('upload-modal');
            const select = document.getElementById('collection-select');

            // Populate select with existing collections + New
            // Use state.collections which is already loaded
            let options = '<option value="home">Home (Root)</option>';
            if (state.collections) {
                Object.keys(state.collections).forEach(c => {
                    options += `<option value="${c}">${c}</option>`;
                });
            }
            options += '<option value="new">+ Create New Collection</option>';
            select.innerHTML = options;

            document.getElementById('new-collection-div').style.display = 'none';
            document.getElementById('upload-status').innerText = '';
            document.getElementById('new-collection-name').value = '';
            document.getElementById('file-upload').value = '';

            modal.classList.add('active');
        }

        function closeUploadModal() {
            document.getElementById('upload-modal').classList.remove('active');
        }

        function toggleNewCollectionInput() {
            const select = document.getElementById('collection-select');
            const newDiv = document.getElementById('new-collection-div');
            newDiv.style.display = select.value === 'new' ? 'block' : 'none';
        }

        async function handleUploadSubmit(e) {
            e.preventDefault();
            const fileInput = document.getElementById('file-upload');
            const select = document.getElementById('collection-select');
            const newNameInput = document.getElementById('new-collection-name');
            const statusDiv = document.getElementById('upload-status');
            const btn = document.getElementById('upload-submit-btn');

            const file = fileInput.files[0];
            if (!file) return;

            // Determine Folder
            let folder = '';
            if (select.value === 'new') {
                const newName = newNameInput.value.trim();
                // Validate folder name (simple)
                if (!newName || !/^[a-zA-Z0-9 _-]+$/.test(newName)) {
                    alert('Invalid collection name. Use letters, numbers, spaces, dashes, or underscores.');
                    return;
                }
                folder = newName;
            } else if (select.value !== 'home') {
                folder = select.value;
            }

            statusDiv.innerText = 'Uploading...';
            btn.disabled = true;

            const reader = new FileReader();
            reader.onload = async function (evt) {
                // The result is "data:image/jpeg;base64,..."
                // We split it here to send cleaner data, OR send full string and handle in backend.
                // Backend now handles both, but let's stick to sending clean base64 if possible
                // or just send the whole thing?
                // Standardizing: Send the split part.
                const base64Content = evt.target.result.split(',')[1];
                const user = getUser();

                try {
                    const res = await fetch('/.netlify/functions/upload', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${user.token}`
                        },
                        body: JSON.stringify({
                            image: base64Content,
                            filename: file.name,
                            folder: folder
                        })
                    });

                    if (res.ok) {
                        statusDiv.style.color = 'green';
                        statusDiv.innerText = 'Upload Successful! Site rebuilding...';

                        // Optimistic UI Update
                        const blobUrl = URL.createObjectURL(file);
                        const tempPhoto = {
                            filename: folder ? `${folder}/${file.name}` : file.name,
                            thumbnail: blobUrl,
                            date: new Date().toISOString(),
                            exif: { model: 'Uploading...' }
                        };

                        // Prepend to Gallery
                        createPhotoElement(tempPhoto, 0);
                        const newResult = gallery.lastChild;
                        if (newResult) {
                            gallery.prepend(newResult);
                            setTimeout(() => newResult.classList.add('visible'), 50);
                        }

                        setTimeout(closeUploadModal, 1500);
                    } else {
                        const data = await res.json().catch(() => ({}));
                        statusDiv.style.color = 'red';
                        statusDiv.innerText = 'Failed: ' + (data.error || 'Unknown error');
                    }
                } catch (err) {
                    console.error(err);
                    statusDiv.style.color = 'red';
                    statusDiv.innerText = 'Network Error';
                } finally {
                    btn.disabled = false;
                }
            };
            reader.readAsDataURL(file);
        }

        async function deletePhoto(filename, element) {
            if (!confirm(`Are you sure you want to delete "${filename}"? This cannot be undone.`)) {
                return;
            }

            const user = getUser();
            // Optimistic UI update: fade out
            element.style.opacity = '0.5';

            try {
                const res = await fetch('/.netlify/functions/delete_photo', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${user.token}`
                    },
                    body: JSON.stringify({ filename })
                });

                if (res.ok) {
                    // Remove from DOM
                    element.remove();

                    // Also remove from local state to prevent errors if using next/prev
                    // Note: This is tricky with shuffle. For now, simple removal visually is enough.
                    // The site will rebuild in 1-2 mins.
                } else {
                    alert("Failed to delete photo.");
                    element.style.opacity = '1';
                }
            } catch (e) {
                console.error(e);
                alert("Network error.");
                element.style.opacity = '1';
            }
        }

        // --- Move Logic ---

        function openMoveModal(filename) {
            const modal = document.getElementById('move-modal');
            const select = document.getElementById('move-collection-select');
            const filenameDisplay = document.getElementById('move-filename');

            filenameDisplay.innerText = `Moving: ${filename}`;

            // Populate Collections (exclude current logic optional, but simpler to show all)
            let options = '<option value="home">Home (Root)</option>';
            if (state.collections) {
                Object.keys(state.collections).forEach(c => {
                    options += `<option value="${c}">${c}</option>`;
                });
            }
            select.innerHTML = options;

            // Store filename on the form/modal for submit handler
            modal.dataset.filename = filename;

            document.getElementById('move-status').innerText = '';
            modal.classList.add('active');
        }

        function closeMoveModal() {
            document.getElementById('move-modal').classList.remove('active');
        }

        async function handleMoveSubmit(e) {
            e.preventDefault();
            const modal = document.getElementById('move-modal');
            const filename = modal.dataset.filename;
            const select = document.getElementById('move-collection-select');
            const statusDiv = document.getElementById('move-status');
            const btn = document.getElementById('move-submit-btn');

            if (!filename) return;

            const targetFolder = select.value === 'home' ? '' : select.value;
            const user = getUser();

            statusDiv.innerText = 'Moving...';
            btn.disabled = true;

            try {
                const res = await fetch('/.netlify/functions/move_photo', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${user.token}`
                    },
                    body: JSON.stringify({
                        filename: filename,
                        targetFolder: targetFolder
                    })
                });

                if (res.ok) {
                    const data = await res.json();
                    statusDiv.style.color = 'green';
                    statusDiv.innerText = 'Move Successful! Rebuilding site...';

                    setTimeout(() => {
                        closeMoveModal();
                        alert('Photo moved. The site will update in ~1 minute.');
                        location.reload();
                    }, 1000);

                } else {
                    const data = await res.json().catch(() => ({}));
                    statusDiv.style.color = 'red';
                    statusDiv.innerText = 'Failed: ' + (data.error || 'Unknown error');
                }
            } catch (err) {
                console.error(err);
                statusDiv.style.color = 'red';
                statusDiv.innerText = 'Network Error';
            } finally {
                btn.disabled = false;
            }
        }

        /* Mobile Menu Logic */
        function toggleMobileMenu(side) {
            const leftMenu = document.getElementById('mobile-menu-left');
            // Single menu now (left)
            if (leftMenu) leftMenu.classList.toggle('active');
        }

        // Close when clicking outside (on overlay)
        document.querySelectorAll('.mobile-menu-overlay').forEach(el => {
            el.addEventListener('click', (e) => {
                if (e.target === el) {
                    el.classList.remove('active');
                }
            });
        });

        function renderMobileMenus() {
            // 1. Unified Left Menu
            const menuContent = document.getElementById('mobile-menu-content');
            if (!menuContent) return;
            menuContent.innerHTML = '';

            const createItem = (label, action, isBold = false) => {
                const item = document.createElement('div');
                item.className = 'nav-item';
                item.innerText = label;
                if (isBold) item.style.fontWeight = 'bold';
                item.onclick = () => {
                    action();
                    toggleMobileMenu('left'); // Close
                };
                return item;
            };

            // -- Collections --
            menuContent.appendChild(createItem('Home', () => switchCollection('Home'), false));
            if (state.collections) {
                Object.keys(state.collections).forEach(c => {
                    menuContent.appendChild(createItem(c, () => switchCollection(c), false));
                });
            }

            // -- Separator --
            const sep = document.createElement('div');
            sep.style.height = '1px';
            sep.style.background = 'var(--nav-separator)';
            sep.style.margin = '10px 0';
            menuContent.appendChild(sep);

            // -- System / Auth --
            const user = getUser();

            // Theme Toggle
            menuContent.appendChild(createItem('Light/Dark', toggleTheme, false));

            if (user) {
                // Upload (Admin only)
                if (user.role === 'admin') {
                    const upBtn = createItem('Upload Photo', triggerUpload, true);
                    upBtn.style.color = 'var(--accent-color)';
                    menuContent.appendChild(upBtn);
                }

                // Log Out
                menuContent.appendChild(createItem('Log Out', logout, true));

                // Display Username on Right Header
                const userDisplay = document.getElementById('mobile-user-display');
                if (userDisplay) userDisplay.innerText = user.username;

            } else {
                // Log In / Sign Up
                menuContent.appendChild(createItem('Log In', () => openAuthModal('login'), true));
                menuContent.appendChild(createItem('Sign Up', () => openAuthModal('signup'), true));

                // Clear Username on Right Header
                const userDisplay = document.getElementById('mobile-user-display');
                if (userDisplay) userDisplay.innerText = '';
            }
        }
        /* Scroll Hide/Show Logic for Mobile */
        let lastScrollTop = 0;


        window.addEventListener('scroll', () => {
            // Only active on mobile
            if (window.innerWidth > 600) return;

            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (scrollTop > lastScrollTop && scrollTop > 100) {
                // Scrolling Down
                header.classList.add('header-hidden');
                // Close menus if open
                document.getElementById('mobile-menu-left').classList.remove('active');
            } else {
                // Scrolling Up or at top
                header.classList.remove('header-hidden');
            }

            lastScrollTop = scrollTop <= 0 ? 0 : scrollTop; // For Mobile or negative scrolling
        }, { passive: true });
    </script>