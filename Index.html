<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exposr</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow-x: hidden;
            overflow-y: scroll;
        }

        header {
            text-align: center;
            padding: 2.5rem 1rem;
            background: #0a0a0a;
            position: relative;
        }

        .logo {
            height: 23px;
            /* Smaller logo */
            width: auto;
            display: block;
            margin: 0 auto;
            opacity: 0.9;
        }

        .gallery {
            padding: 0 1rem;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            /* 3 Columns like reference */
            gap: 24px;
            grid-auto-rows: 20px;
            /* Base row height for masonry calculations */
            grid-auto-flow: dense;
            width: 100%;
            max-width: 1600px;
            /* Constrain width */
            margin: 0 auto;
            /* Center gallery */
        }

        @media (max-width: 1200px) {
            .gallery {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            .gallery {
                grid-template-columns: 1fr;
            }

            /* Force single column spans on mobile to prevent overflow/misalignment */
            .w-1,
            .w-2,
            .w-3 {
                grid-column: span 1 !important;
            }
        }

        .photo-item {
            position: relative;
            cursor: pointer;
            overflow: hidden;
            background: #111;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease, transform 0.6s ease;
            /* Removed content-visibility to prevent layout gaps with dense grid */
        }

        .photo-item.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .photo-item img {
            width: 100%;
            height: 100%;
            display: block;
            transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), opacity 0.3s;
            object-fit: cover;
            border-radius: 0;
            opacity: 0;
        }

        .photo-item img.loaded {
            opacity: 1;
        }

        .photo-item:hover img {
            transform: scale(1.03);
        }

        /* Grid Spans */
        .w-1 {
            grid-column: span 1;
        }

        .w-2 {
            grid-column: span 2;
        }

        .w-3 {
            grid-column: span 3;
        }



        .photo-info {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 2rem 1.5rem 1.5rem;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.9), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
            font-size: 0.9rem;
            /* Increased from 0.75rem */
            pointer-events: none;
        }

        .photo-item:hover .photo-info {
            opacity: 1;
        }

        .photo-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.2rem;
            letter-spacing: 0.02em;
        }

        .photo-date {
            font-size: 0.85rem;
            color: #ccc;
            margin-bottom: 0.2rem;
            font-weight: 500;
        }

        .info-line {
            line-height: 1.4;
            color: #aaa;
            font-weight: 400;
        }

        /* Lightbox */
        .lightbox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--lightbox-bg);
            /* Updated to use theme variable */
            display: flex;
            /* keep flex, but we toggle visibility with class */
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .lightbox.active {
            opacity: 1;
            pointer-events: auto;
        }

        .lightbox-close {
            position: absolute;
            top: 1.5rem;
            right: 2rem;
            background: none;
            border: none;
            color: var(--lightbox-text);
            font-size: 2rem;
            cursor: pointer;
            z-index: 1010;
            opacity: 0.7;
            transition: opacity 0.2s, color 0.3s;
            padding: 10px;
        }

        .lightbox-close:hover {
            opacity: 1;
        }

        .lightbox-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--lightbox-arrow);
            font-size: 3rem;
            cursor: pointer;
            padding: 2rem;
            z-index: 1010;
            transition: color 0.2s;
        }

        .lightbox-arrow:hover {
            color: var(--lightbox-arrow-hover);
        }

        .arrow-prev {
            left: 0;
        }

        .arrow-next {
            right: 0;
        }

        .lightbox-content {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            overflow: hidden;
            padding-bottom: 2rem;
        }

        .lightbox-img-wrapper {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            overflow: hidden;
        }

        .lightbox-img-wrapper:active {
            cursor: grabbing;
        }

        .lightbox img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transform-origin: 0 0;
            will-change: transform;
            user-select: none;
        }

        .lightbox-overlay {
            position: relative;
            width: 100%;
            text-align: center;
            pointer-events: none;
            padding-top: 1rem;
            color: var(--lightbox-meta);
            flex-shrink: 0;
            left: auto;
            bottom: auto;
            transform: none;
            text-shadow: none;
        }

        .lightbox-title {
            font-size: 1rem;
            font-weight: 500;
            color: var(--lightbox-text);
        }

        .lightbox-meta {
            font-size: 0.8rem;
            color: var(--lightbox-meta);
            margin-top: 0.3rem;
        }

        .loading-sentinel {
            width: 100%;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            margin-top: 2rem;
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 2px solid var(--spinner-border);
            border-top: 2px solid var(--spinner-active);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        :root {
            --bg-color: #0a0a0a;
            --text-color: #fff;
            --header-bg: rgba(0, 0, 0, 0.8);
            --header-bg-sticky: rgba(0, 0, 0, 0.95);
            --nav-text: #888;
            --nav-text-hover: #fff;
            --nav-separator: rgba(255, 255, 255, 0.4);
            --lightbox-bg: rgba(10, 10, 10, 0.98);
            --lightbox-text: #fff;
            --lightbox-arrow: rgba(255, 255, 255, 0.5);
            --lightbox-arrow-hover: #fff;
            --lightbox-meta: #aaa;
            --spinner-border: #333;
            --spinner-active: #fff;
        }

        body.light-mode {
            --bg-color: #f2f2f2;
            --text-color: #333;
            --header-bg: rgba(242, 242, 242, 0.8);
            --header-bg-sticky: rgba(242, 242, 242, 0.95);
            --nav-text: #666;
            --nav-text-hover: #000;
            --nav-separator: rgba(0, 0, 0, 0.2);
            --lightbox-bg: rgba(242, 242, 242, 0.98);
            --lightbox-text: #333;
            --lightbox-arrow: rgba(0, 0, 0, 0.5);
            --lightbox-arrow-hover: #000;
            --lightbox-meta: #666;
            --spinner-border: #ddd;
            --spinner-active: #666;
            --spinner-active: #666;
            --auth-bg: #fff;
            --auth-text: #333;
        }

        /* Auth Styles */
        .auth-box {
            background: var(--auth-bg);
            color: var(--auth-text);
            padding: 2rem;
            width: 100%;
            max-width: 320px;
            border-radius: 4px;
            text-align: center;
        }

        .auth-box h2 {
            margin-bottom: 1.5rem;
            font-weight: 500;
        }

        .auth-box input {
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            background: transparent;
            color: inherit;
            font-family: inherit;
        }

        .auth-box button[type="submit"] {
            width: 100%;
            padding: 0.8rem;
            background: #000;
            color: #fff;
            border: none;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        body.light-mode .auth-box button[type="submit"] {
            background: #333;
        }

        .auth-switch {
            margin-top: 1rem;
            font-size: 0.85rem;
            color: #888;
        }

        #auth-switch-btn {
            background: none;
            border: none;
            color: inherit;
            text-decoration: underline;
            cursor: pointer;
            font-family: inherit;
            margin-left: 0.3rem;
        }

        .auth-error {
            color: red;
            font-size: 0.85rem;
            margin-top: 1rem;
            min-height: 1.2em;
        }

        /* User Menu Item */
        .nav-user {
            font-family: 'Outfit', sans-serif;
            font-size: 0.8rem;
            color: var(--nav-text);
            margin-left: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-login-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--nav-text);
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-size: 0.8rem;
        }

        .nav-login-btn:hover {
            color: var(--nav-text-hover);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow-x: hidden;
            overflow-y: scroll;
            transition: background 0.3s ease, color 0.3s ease;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Header & Nav */
        header {
            position: sticky;
            top: 0;
            z-index: 1000;
            padding: 2rem 0;
            /* Remove horizontal padding from header */
            background: var(--header-bg);
            backdrop-filter: blur(10px);
            transition: all 0.4s ease;
            width: 100%;
            box-sizing: border-box;
        }

        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1600px;
            /* Match gallery max-width */
            margin: 0 auto;
            padding: 0 2rem;
            /* Add horizontal padding here */
            box-sizing: border-box;
        }

        header.sticky {
            padding: 0.8rem 0;
            background: var(--header-bg-sticky);
        }

        header.sticky .logo-link {
            opacity: 0;
            pointer-events: none;
            max-width: 0;
            margin: 0;
        }

        .logo-link {
            order: 2;
            display: flex;
            align-items: center;
            text-decoration: none;
            transition: all 0.4s ease;
            max-width: 500px;
            /* Increased to fit full logo */
            overflow: hidden;
            white-space: nowrap;
        }

        .logo {
            height: 28px;
            width: auto;
            transition: all 0.4s ease;
        }

        /* Logo Theme Logic */
        .logo-light {
            display: none;
        }

        .logo-dark {
            display: block;
        }

        body.light-mode .logo-light {
            display: block;
        }

        body.light-mode .logo-dark {
            display: none;
        }

        .nav-wrapper {
            display: flex;
            align-items: center;
            flex: 1;
            order: 1;
            overflow: hidden;
            position: relative;
        }

        #main-nav {
            display: flex;
            gap: 30px;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            scroll-behavior: smooth;
            align-items: center;
        }

        #main-nav::-webkit-scrollbar {
            display: none;
        }

        .nav-item {
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            /* Tiny bit smaller */
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--nav-text);
            cursor: pointer;
            transition: color 0.3s ease;
            white-space: nowrap;
            padding: 0.5rem 0;
            user-select: none;

            /* Reset vertical/rotation properties */
            writing-mode: horizontal-tb;
            text-orientation: initial;
            transform: none;
        }

        .nav-item:hover,
        .nav-item.active {
            color: var(--nav-text-hover);
        }

        .nav-separator {
            width: 1px;
            height: 14px;
            background-color: var(--nav-separator);
            margin: 0 15px;
            display: inline-block;
            vertical-align: middle;
        }

        /* Theme Toggle */
        .theme-toggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem 0;
            color: var(--nav-text);
            transition: color 0.3s ease;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .theme-toggle:hover {
            color: var(--nav-text-hover);
        }

        .mobile-upload-btn {
            display: none;
            /* Hidden on desktop */
        }

        .nav-upload-btn {
            background: #fff;
            color: #000;
            border: 1px solid #fff;
            padding: 0.5rem 1.2rem;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 15px;
        }

        .nav-upload-btn:hover {
            background: transparent;
            color: #fff;
        }

        body.light-mode .nav-upload-btn {
            background: #000;
            color: #fff;
            border-color: #000;
        }

        body.light-mode .nav-upload-btn:hover {
            background: transparent;
            color: #000;
        }

        .nav-arrow {
            display: none;
        }

        /* Mobile Navigation */
        @media (max-width: 600px) {
            header {
                padding: 1rem 0;
                position: sticky;
            }

            .header-container {
                flex-direction: column;
                gap: 1rem;
                padding: 0 1rem;
            }

            .logo-link {
                order: 1;
                margin-bottom: 0.5rem;
                display: block;
                /* Ensure it behaves as block for centering if needed */
                max-width: none;
                /* Reset desktop constraint */
                max-height: 100px;
                /* For smooth mobile transition */
            }

            .logo {
                height: 24px;
                /* Removed overrides */
                transition: all 0.4s ease;
            }

            header.sticky .logo-link {
                max-height: 0;
                margin: 0;
                opacity: 0;
                pointer-events: none;
            }

            .nav-wrapper {
                order: 2;
                width: 100%;
                justify-content: flex-start;
                /* Left align wrapper */
                /* Fade only on right side */
                -webkit-mask-image: linear-gradient(90deg, #000 0%, #000 85%, transparent);
                mask-image: linear-gradient(90deg, #000 0%, #000 85%, transparent);
            }

            #main-nav {
                width: 100%;
                gap: 20px;
                padding: 0 20px 0 0;
                /* Padding only on right for fade */
                justify-content: flex-start;
                /* Prevent cropping on left */
            }

            /* Allow scrolling if content overflows */
            #main-nav {
                /* For centering to work when wrapping isn't enabled, we need to be careful.
                   With overflow-x: auto and flex, justify-content: center will clip start if overflowing.
                   Safe way: use margin: auto on items or just accept start alignment if overflow.
                   BUT user specifically said "centered". Usually means visual center. 
                   If items fit, they are centered. If they don't, they are scrollable.
                   A common trick: margin: 0 auto; on the flex container logic? No. 
                   Let's stick to justify-content: center, but note the clipping risk. 
                   Wait, `safe center` value exists but unrelated support.
                   
                   Alternative: Use ::before and ::after spacers?
                   
                   Let's try justify-content: center. If the list is huge, the first items might be inaccessible.
                   However, we only have a few collections usually. "only 2-3 are shown at a time".
                   So it WILL overflow. 
                   
                   If it overflows, we MUST NOT use justify-content: center (unsafe).
                   We should use justify-content: flex-start.
                   
                   BUT user said "mobile that menu should be centered". 
                   Maybe they mean the *container* is centered in the screen (it is).
                   Or the active item is centered?
                   
                   "horizontally scrollable so only 2-3 are shown at a time"
                   
                   Let's set `justify-content: flex-start` but add padding to pseudo-center?
                   
                   Actually, let's keep `justify-content: center` for now? No, checking standard practice.
                   If it scrolls, `flex-start` is best. 
                   To make it look centered when few items: `margin: 0 auto`.
                   
                   Let's try `justify-content: center`. If user has many collections, I might need to fix. 
                   Given currently only 1 collection + home = 2 items. They will fit. 
                   So center is fine.
                */
            }

            .nav-arrow {
                display: none;
                /* Left align wrapper */
                /* Fade only on right side */
                -webkit-mask-image: linear-gradient(90deg, #000 0%, #000 85%, transparent);
                mask-image: linear-gradient(90deg, #000 0%, #000 85%, transparent);
            }

            .mobile-upload-btn {
                display: block;
                order: 2;
                /* After logo (1), before nav (3) */
                width: 100%;
                /* Own line, full width */
                margin: 0;
                text-align: center;
                transition: all 0.4s ease;
                background: var(--text-color);
                /* Inverse */
                color: var(--bg-color);
                /* Inverse */
                border-color: var(--text-color);
            }

            .mobile-upload-btn:hover {
                background: transparent;
                color: var(--text-color);
            }

            /* Hide desktop button on mobile */
            .nav-wrapper .nav-upload-btn {
                display: none;
            }

            /* Sticky Hiding for Mobile Upload Btn */
            header.sticky .mobile-upload-btn {
                max-height: 0;
                margin: 0;
                padding: 0;
                border: 0;
                opacity: 0;
                pointer-events: none;
                overflow: hidden;
            }

            #main-nav {
                width: 100%;
                gap: 20px;
                padding: 0 20px 0 0;
                /* Padding only on right for fade */
                justify-content: flex-start;
                /* Prevent cropping on left */
            }

            /* Update orders for correct flow */
            .logo-link {
                order: 1;
            }

            .mobile-upload-btn {
                display: none;
                /* Default hidden */
                order: 2;
                margin-bottom: 0.5rem;
            }

            /* Only show if admin */
            body.is-admin .mobile-upload-btn {
                display: block;
            }

            .nav-wrapper {
                order: 3;
            }

            .nav-arrow {
                display: none;
                /* Hide arrows on mobile as requested */
            }

            /* Auth Box Mobile overrides */
            .auth-box {
                width: 90%;
            }
        }
    </style>
</head>

<body>
    <header id="main-header">
        <div class="header-container">
            <button class="nav-upload-btn mobile-upload-btn" onclick="triggerUpload()">Upload</button>
            <div class="nav-wrapper">
                <button class="nav-arrow nav-arrow-left" onclick="scrollNav(-1)">‹</button>
                <nav id="main-nav"></nav>
                <button class="nav-arrow nav-arrow-right" onclick="scrollNav(1)">›</button>
            </div>
            <a href="About.html" class="logo-link">
                <img src="Website assets/exposr_name.svg" alt="exposr" class="logo logo-dark">
                <img src="Website assets/exposr_name - forLightBG.svg" alt="exposr" class="logo logo-light">
            </a>
        </div>
    </header>

    <div class="gallery" id="gallery"></div>
    <div class="loading-sentinel" id="sentinel">
        <div class="spinner"></div>
    </div>

    <!-- Lightbox -->
    <div class="lightbox" id="lightbox">
        <button class="lightbox-close" onclick="closeLightbox()">×</button>
        <button class="lightbox-arrow arrow-prev" onclick="navigate(-1)">‹</button>
        <button class="lightbox-arrow arrow-next" onclick="navigate(1)">›</button>

        <div class="lightbox-content">
            <div class="lightbox-img-wrapper" id="zoom-container">
                <img id="lightbox-img" src="" alt="">
            </div>
            <div class="lightbox-overlay" id="lightbox-info"></div>
        </div>
    </div>

    <!-- Login / Signup Modal -->
    <div class="lightbox" id="auth-modal">
        <button class="lightbox-close" onclick="closeAuthModal()">×</button>
        <div class="auth-box">
            <h2 id="auth-title">Login</h2>
            <form id="auth-form" onsubmit="handleAuth(event)">
                <input type="text" id="auth-username" placeholder="Username" required>
                <input type="password" id="auth-password" placeholder="Password" required>
                <button type="submit" id="auth-submit">Login</button>
            </form>
            <div class="auth-switch">
                <span id="auth-switch-text">New here?</span>
                <button onclick="toggleAuthMode()" id="auth-switch-btn">Sign Up</button>
            </div>
            <div id="auth-error" class="auth-error"></div>
        </div>
    </div>

    <script>
        // State
        const state = {
            homePhotos: [],
            collections: {},
            currentPhotos: [], // The array currently being displayed
            loadedCount: 0,
            batchSize: 24,
            isLoading: false
        };

        const zoom = {
            scale: 1,
            panning: false,
            pointX: 0,
            pointY: 0,
            startX: 0,
            startY: 0
        };

        // Utility: Fisher-Yates Shuffle
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // DOM Elements
        const gallery = document.getElementById('gallery');
        const sentinel = document.getElementById('sentinel');
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = document.getElementById('lightbox-img');
        const zoomContainer = document.getElementById('zoom-container');

        // Initialize
        async function init() {
            try {
                const response = await fetch('photos.json');
                const data = await response.json();

                // Handle new data structure
                state.homePhotos = data.home || [];
                state.collections = data.collections || {};

                // Shuffle everything
                shuffleArray(state.homePhotos);
                for (const key in state.collections) {
                    shuffleArray(state.collections[key]);
                }

                // Default to Home
                switchCollection('Home');

                // Init Theme
                initTheme();

                // Render Sidebar (renamed)
                renderNav();

                // Setup Infinite Scroll
                const observer = new IntersectionObserver((entries) => {
                    if (entries[0].isIntersecting && !state.isLoading) {
                        loadMorePhotos();
                    }
                }, { rootMargin: '200px' });

                observer.observe(sentinel);

            } catch (error) {
                console.error('Failed to load photos:', error);
                sentinel.innerHTML = 'Error loading photos.';
            }
        }

        function switchCollection(name) {
            // Update State
            if (name === 'Home') {
                state.currentPhotos = state.homePhotos;
            } else {
                state.currentPhotos = state.collections[name];
            }

            state.loadedCount = 0;
            state.isLoading = false;

            // Allow re-triggering sentinel
            sentinel.style.display = 'flex';
            sentinel.innerHTML = '<div class="spinner"></div>';

            // Clear Grid
            gallery.innerHTML = '';

            // Load initial batch
            if (state.currentPhotos.length === 0) {
                sentinel.innerHTML = 'No photos found.';
            } else {
                loadMorePhotos();

                // Re-observe sentinel if it was disconnected or hidden
                // (Observer usually stays active on element, but we ensure display is flex)
            }
        }

        function loadMorePhotos() {
            if (state.loadedCount >= state.currentPhotos.length) {
                sentinel.style.display = 'none';
                return;
            }

            state.isLoading = true;
            const batch = state.currentPhotos.slice(state.loadedCount, state.loadedCount + state.batchSize);

            batch.forEach((filename, i) => {
                const globalIndex = state.loadedCount + i;
                createPhotoElement(filename, globalIndex);
            });

            state.loadedCount += batch.length;
            state.isLoading = false;
        }

        function createPhotoElement(filename, index) {
            const item = document.createElement('div');
            item.className = 'photo-item';

            const img = document.createElement('img');
            img.src = `Photos/${filename}`;
            img.loading = 'lazy';

            const info = document.createElement('div');
            info.className = 'photo-info';

            // Wait for image dimensions to determine grid span
            img.onload = function () {
                img.classList.add('loaded');
                item.classList.add('visible');

                const ratio = this.naturalWidth / this.naturalHeight;
                assignGridSpan(item, ratio);

                // Load EXIF
                EXIF.getData(img, function () {
                    const exifData = EXIF.getAllTags(this);
                    const meta = extractExifInfo(exifData);
                    info.innerHTML = meta.html;

                    // Store metadata for lightbox
                    // (We use dataset on the image element instead)
                    img.dataset.metaTitle = meta.title;
                    img.dataset.metaDetails = meta.details;
                    img.dataset.metaDate = meta.date;
                });
            };

            item.appendChild(img);
            item.appendChild(info);
            item.onclick = () => openLightbox(index);
            gallery.appendChild(item);
        }

        function assignGridSpan(element, ratio) {
            // Store ratio for potential resize recalculations
            element.dataset.ratio = ratio;

            // 1. Assign Width randomly (keep variety) if not already assigned
            // We check if it has a width class? No, just overwrite or set.
            // But we should only set w-class once to avoid jumping on resize.
            // Check if w-1 or w-2 is present?
            let hasWidth = element.classList.contains('w-1') || element.classList.contains('w-2');

            if (!hasWidth) {
                const rand = Math.random();
                element.classList.remove('h-1', 'h-2'); // clear previous

                if (ratio > 1.5) {
                    // Panoramic / Wide Landscape
                    if (rand > 0.85) { element.classList.add('w-2'); } // Wide (Very rare: 15% chance only for very wide shots)
                    else { element.classList.add('w-1'); } // Regular
                } else {
                    // Everyone else (Standard Landscape, Square, Portrait)
                    // Strict w-1 to ensure grid holes are always fillable
                    element.classList.add('w-1');
                }
            }

            // 2. Calculate Row Span
            const width = element.offsetWidth;
            if (width > 0) {
                const targetHeight = width / ratio;
                const rowHeight = 20; // Matches CSS grid-auto-rows
                const gap = 24;       // Matches CSS gap

                // span = (height + gap) / (rowHeight + gap)
                const rowSpan = Math.ceil((targetHeight + gap) / (rowHeight + gap));
                element.style.gridRowEnd = `span ${rowSpan}`;
            }
        }

        // recalculate on resize
        window.addEventListener('resize', () => {
            const items = document.querySelectorAll('.photo-item');
            items.forEach(item => {
                if (item.dataset.ratio) {
                    assignGridSpan(item, parseFloat(item.dataset.ratio));
                }
            });
        });

        function extractExifInfo(exif) {
            const title = exif.ImageDescription || '';
            const details = [];

            // Camera Model
            if (exif.Model) details.push(exif.Model);

            // Lens (check LensModel and Lens)
            if (exif.LensModel) details.push(exif.LensModel);
            else if (exif.Lens) details.push(exif.Lens);

            // Focal Length (standard or 35mm equiv)
            if (exif.FocalLength) {
                details.push(`${Math.round(Number(exif.FocalLength))}mm`);
            } else if (exif.FocalLengthIn35mmFilm) {
                details.push(`${exif.FocalLengthIn35mmFilm}mm`);
            }

            // Aperture
            if (exif.FNumber) details.push(`f/${exif.FNumber}`);

            // Shutter Speed
            if (exif.ExposureTime) {
                const t = exif.ExposureTime;
                details.push(t < 1 ? `1/${Math.round(1 / t)}s` : `${t}s`);
            }

            // ISO
            if (exif.ISOSpeedRatings) details.push(`ISO ${exif.ISOSpeedRatings}`);

            // EV (Robust check)
            if (exif.ExposureBiasValue !== undefined && exif.ExposureBiasValue !== null) {
                const ev = Number(exif.ExposureBiasValue);
                if (!isNaN(ev)) {
                    const sign = ev > 0 ? '+' : '';
                    details.push(`${sign}${ev.toFixed(1)} EV`);
                }
            }

            const detailsStr = details.join(' · ');

            // Parsing Date Time Original
            let dateStr = '';
            if (exif.DateTimeOriginal) {
                const match = exif.DateTimeOriginal.match(/^(\d{4}):(\d{2}):(\d{2})\s(\d{2}):(\d{2})/);
                if (match) {
                    dateStr = `${match[1]}-${match[2]}-${match[3]} ${match[4]}:${match[5]}`;
                } else {
                    dateStr = exif.DateTimeOriginal;
                }
            }

            return {
                title: title,
                details: detailsStr,
                date: dateStr,
                html: `
                    ${title ? `<div class="photo-title">${title}</div>` : ''}
                    ${dateStr ? `<div class="photo-date">${dateStr}</div>` : ''}
                    <div class="info-line">${detailsStr}</div>
                `
            };
        }

        // --- Lightbox Logic ---

        function openLightbox(index) {
            state.currentIndex = index;
            updateLightboxContent();
            lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeLightbox() {
            lightbox.classList.remove('active');
            document.body.style.overflow = 'auto'; // restore scroll
            resetZoom();
        }

        function navigate(dir) {
            // Find actual number of loaded items to avoid bounds error if we clicked a not-yet-loaded index?
            // Actually relying on DOM elements for source is safer.
            const items = document.querySelectorAll('.photo-item img');
            state.currentIndex = (state.currentIndex + dir + items.length) % items.length;
            updateLightboxContent();
        }

        function updateLightboxContent() {
            const items = document.querySelectorAll('.photo-item img');
            const targetImg = items[state.currentIndex];

            if (!targetImg) return;

            lightboxImg.src = targetImg.src;

            const infoBox = document.getElementById('lightbox-info');
            const title = targetImg.dataset.metaTitle || '';
            const details = targetImg.dataset.metaDetails || '';
            const date = targetImg.dataset.metaDate || '';

            infoBox.innerHTML = `
                ${title ? `<div class="lightbox-title">${title}</div>` : ''}
                <div class="lightbox-meta">
                    ${date ? `<span>${date}</span>` : ''}
                    ${date && details ? ' · ' : ''}
                    ${details}
                </div>
            `;

            resetZoom();
        }

        // --- Zoom & Pan Logic (Cursor Centered) ---

        function resetZoom() {
            zoom.scale = 1;
            zoom.pointX = 0;
            zoom.pointY = 0;
            applyTransform();
        }

        function applyTransform() {
            lightboxImg.style.transform = `translate(${zoom.pointX}px, ${zoom.pointY}px) scale(${zoom.scale})`;
        }

        zoomContainer.addEventListener('wheel', (e) => {
            e.preventDefault();

            // 1. Get mouse position relative to the image container
            const rect = zoomContainer.getBoundingClientRect();
            // We want the position relative to the center of the viewport/container because our transform origin is not set to 0 0 in CSS?
            // Wait, in CSS I set transform-origin: 0 0; 
            // This simplifies math: everything starts at top-left.
            // Actually, centering the image is done by flexbox.
            // Let's use the image's own rect.

            const imgRect = lightboxImg.getBoundingClientRect();

            // Mouse position relative to the image's current top-left
            const mouseX = e.clientX - imgRect.left;
            const mouseY = e.clientY - imgRect.top;

            // Determine new scale
            const delta = -Math.sign(e.deltaY) * 0.5;
            const newScale = Math.min(Math.max(1, zoom.scale + delta), 5);

            if (newScale === zoom.scale) return; // No change

            // 2. Adjust translation
            // Logic: The point under the mouse (mouseX, mouseY) should remain at the same screen coordinate.
            // (mouseX / oldScale) = "original pixel x"
            // We want (original pixel x) * newScale + newTranslateX = ScreenX (where ScreenX is e.clientX - container.left?? No.)

            // Standard Zoom-at-point algorithm:
            // translate -= (mouseX / scale) * (newScale - scale)
            // But we need to account for our specific transform setup.

            // Let's do it relative to the current translation (zoom.pointX/Y).
            // The coordinate in "unscaled local space" is:
            // localX = (e.clientX - (containerRect.left + containerWidth/2 - imgWidth/2) - currentTranslateX) / currentScale
            // This is getting complicated because of Flex centering.

            /* Simplified Approach that works robustly with transform-origin: 0 0 */
            /* We need to track the "virtual" top-left corner */

            const contentRect = zoomContainer.getBoundingClientRect();
            // Calculate mouse offset from the content center (where image is centered broadly) is not enough.

            // Let's stick to the relative shift.
            // The mouse is at `e.clientX`, `e.clientY`.
            // The image is currently at `imgRect.left`, `imgRect.top`.
            // The point clicked on the image is `ptrX = (e.clientX - imgRect.left) / zoom.scale`.

            // After scaling, we want that same point `ptrX` to be at `e.clientX`.
            // So: `imgNewLeft + ptrX * newScale = e.clientX`
            // `imgNewLeft = e.clientX - ptrX * newScale`

            // We control `zoom.pointX/Y`. 
            // Note: `imgRect.left` includes the flexbox centering offset! 
            // We can't easily control that via `translate`.
            // BUT: `transform` is applied *after* layout.
            // If `transform-origin` is `0 0`, the transform applies to the top-left of the element.
            // The element is centered by flex.

            // Let MainOffset be the offset of the image top-left from window 0,0 when scale=1, translate=0.
            // We can calculate BaseX = imgRect.left - zoom.pointX.

            const BaseX = imgRect.left - zoom.pointX;
            const BaseY = imgRect.top - zoom.pointY;

            const ptrX = (e.clientX - imgRect.left) / zoom.scale;
            const ptrY = (e.clientY - imgRect.top) / zoom.scale;

            zoom.scale = newScale;

            // New position (left/top)
            // NewLeft = BaseX + newTranslateX
            // We want: NewLeft + ptrX * newScale = e.clientX
            // BaseX + newTranslateX + ptrX * newScale = e.clientX
            // newTranslateX = e.clientX - BaseX - ptrX * newScale

            zoom.pointX = e.clientX - BaseX - (ptrX * newScale);
            zoom.pointY = e.clientY - BaseY - (ptrY * newScale);

            applyTransform();
        });

        // Pan Support
        zoomContainer.addEventListener('mousedown', (e) => {
            if (zoom.scale <= 1) return;
            e.preventDefault();
            zoom.panning = true;
            zoom.startX = e.clientX - zoom.pointX;
            zoom.startY = e.clientY - zoom.pointY;
        });

        document.addEventListener('mousemove', (e) => {
            if (!zoom.panning) return;
            e.preventDefault();
            zoom.pointX = e.clientX - zoom.startX;
            zoom.pointY = e.clientY - zoom.startY;
            applyTransform();
        });

        document.addEventListener('mouseup', () => {
            zoom.panning = false;
        });

        // Keyboard
        document.addEventListener('keydown', (e) => {
            if (!lightbox.classList.contains('active')) return;
            if (e.key === 'Escape') closeLightbox();
            if (e.key === 'ArrowLeft') navigate(-1);
            if (e.key === 'ArrowRight') navigate(1);
        });

        // Initialize
        init();
        initTheme();

        // Theme Logic
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
            }
        }

        function toggleTheme() {
            const isLight = document.body.classList.toggle('light-mode');
            localStorage.setItem('theme', isLight ? 'light' : 'dark');
            renderNav(); // Re-render to update icon
        }

        /* New Logic */

        // Sticky Header Logic
        const header = document.getElementById('main-header');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 50) {
                header.classList.add('sticky');
            } else {
                header.classList.remove('sticky');
            }
        });

        // Mobile Nav Scroll Logic
        function scrollNav(direction) {
            const nav = document.getElementById('main-nav');
            const scrollAmount = 150; // Approx width of items
            nav.scrollBy({ left: direction * scrollAmount, behavior: 'smooth' });
        }

        function renderNav() {
            const nav = document.getElementById('main-nav');
            if (!nav) return;

            nav.innerHTML = '';

            const createItem = (label, isActive = false) => {
                const item = document.createElement('div');
                item.className = 'nav-item';
                if (isActive) item.classList.add('active');
                item.innerText = label;
                item.onclick = () => {
                    document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');
                    switchCollection(label);
                };
                return item;
            };

            nav.appendChild(createItem('Home', true));

            Object.keys(state.collections).forEach(name => {
                nav.appendChild(createItem(name));
            });



            // Add Separator
            const separator = document.createElement('div');
            separator.className = 'nav-separator';
            nav.appendChild(separator);

            // Theme Toggle
            const isLight = document.body.classList.contains('light-mode');
            const toggle = document.createElement('button');
            toggle.className = 'theme-toggle';
            toggle.onclick = toggleTheme;

            // Icons
            // Icons
            const icon = `<svg viewBox="0 0 8.46666 8.46667" fill="currentColor"><g transform="translate(-487.865 81.136)"><path d="m492.09881-80.34216c-1.89649 0-3.4401 1.543096-3.4401 3.439583 0 1.896488 1.54361 3.4401 3.4401 3.4401 1.8965 0 3.4401-1.543612 3.4401-3.4401 0-1.896487-1.5436-3.439583-3.4401-3.439583zm.2651.541569c1.48562.133364 2.6448 1.376901 2.6448 2.898014 0 1.521115-1.15918 2.764651-2.6448 2.898015z" stroke-width="0"/></g></svg>`;

            // Text instead of Icon
            toggle.innerText = "Light/Dark";
            toggle.title = isLight ? "Switch to Dark Mode" : "Switch to Light Mode";
            nav.appendChild(toggle);

            // Upload Button (Only if Admin)
            const user = getUser();
            if (user && user.role === 'admin') {
                const uploadBtn = document.createElement('button');
                uploadBtn.className = 'nav-upload-btn';
                uploadBtn.innerText = 'Upload'; // Boxed and dominant
                uploadBtn.onclick = triggerUpload;
                nav.appendChild(uploadBtn);

                // Show Mobile Upload Btn
                document.body.classList.add('is-admin');
            } else {
                // Hide Mobile Upload Btn
                document.body.classList.remove('is-admin');
            }

            // User / Login
            const userDiv = document.createElement('div');
            userDiv.className = 'nav-user';

            if (user) {
                userDiv.innerHTML = `
                    <span>${user.username}</span>
                    <button class="nav-login-btn" onclick="logout()">Logout</button>
                `;
            } else {
                userDiv.innerHTML = `<button class="nav-login-btn" onclick="openAuthModal()">Login</button>`;
            }
            nav.appendChild(userDiv);
        }

        // --- Auth Logic ---
        let authMode = 'login'; // 'login' or 'signup'

        function getUser() {
            try {
                const u = localStorage.getItem('user');
                return u ? JSON.parse(u) : null;
            } catch (e) { return null; }
        }

        function openAuthModal() {
            document.getElementById('auth-modal').classList.add('active');
            resetAuthForm();
        }

        function closeAuthModal() {
            document.getElementById('auth-modal').classList.remove('active');
        }

        function toggleAuthMode() {
            authMode = authMode === 'login' ? 'signup' : 'login';
            resetAuthForm();
        }

        function resetAuthForm() {
            const title = document.getElementById('auth-title');
            const submit = document.getElementById('auth-submit');
            const switchText = document.getElementById('auth-switch-text');
            const switchBtn = document.getElementById('auth-switch-btn');
            const error = document.getElementById('auth-error');

            error.innerText = '';
            document.getElementById('auth-form').reset();

            if (authMode === 'login') {
                title.innerText = 'Login';
                submit.innerText = 'Login';
                switchText.innerText = 'New here?';
                switchBtn.innerText = 'Sign Up';
            } else {
                title.innerText = 'Sign Up';
                submit.innerText = 'Sign Up';
                switchText.innerText = 'Already have an account?';
                switchBtn.innerText = 'Login';
            }
        }

        async function handleAuth(e) {
            e.preventDefault();
            const username = document.getElementById('auth-username').value;
            const password = document.getElementById('auth-password').value;
            const errorDiv = document.getElementById('auth-error');
            const btn = document.getElementById('auth-submit');

            errorDiv.innerText = '';
            btn.disabled = true;

            const endpoint = authMode === 'login' ? '/.netlify/functions/login' : '/.netlify/functions/signup';

            try {
                const res = await fetch(endpoint, {
                    method: 'POST',
                    body: JSON.stringify({ username, password })
                });
                const data = await res.json();

                if (res.ok) {
                    if (authMode === 'signup') {
                        // Switch to login
                        authMode = 'login';
                        resetAuthForm();
                        errorDiv.style.color = 'green';
                        errorDiv.innerText = "Signup success! Please login.";
                    } else {
                        // Login Success
                        localStorage.setItem('user', JSON.stringify({
                            username: data.username,
                            role: data.role,
                            token: data.token
                        }));
                        closeAuthModal();
                        renderNav(); // Update UI
                    }
                } else {
                    errorDiv.style.color = 'red';
                    errorDiv.innerText = data.error || 'Request failed';
                }
            } catch (err) {
                errorDiv.innerText = 'Network Error';
            } finally {
                btn.disabled = false;
            }
        }

        function logout() {
            localStorage.removeItem('user');
            renderNav();
        }


        // --- Upload Logic ---
        function triggerUpload() {
            // Check auth again
            const user = getUser();
            if (!user || user.role !== 'admin') {
                alert("Unauthorized");
                return;
            }

            // Create a hidden file input
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/jpeg, image/png'; // basic restriction
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                // Simple size check (e.g. 6MB limit for Netlify Functions body)
                if (file.size > 6 * 1024 * 1024) {
                    alert('File is too large! Please upload photos under 6MB.');
                    return;
                }

                const btn = document.querySelector('.nav-upload-btn');
                const originalText = btn.innerText;
                btn.innerText = 'Uploading...';
                btn.style.opacity = '0.7';
                btn.disabled = true;

                try {
                    // Convert to Base64
                    const reader = new FileReader();
                    reader.onload = async function () {
                        const base64Data = reader.result;

                        try {
                            const response = await fetch('/.netlify/functions/upload', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${user.token}`
                                },
                                body: JSON.stringify({
                                    image: base64Data,
                                    filename: file.name
                                })
                            });

                            if (response.ok) {
                                alert('Upload Successful! Your photo will appear in a few minutes after the site rebuilds.');
                            } else {
                                const err = await response.json();
                                alert('Upload Failed: ' + (err.error || 'Unknown error'));
                            }
                        } catch (netErr) {
                            alert('Network Error during upload.');
                            console.error(netErr);
                        } finally {
                            btn.innerText = originalText;
                            btn.style.opacity = '1';
                            btn.disabled = false;
                        }
                    };
                    reader.readAsDataURL(file);

                } catch (err) {
                    console.error(err);
                    btn.innerText = originalText;
                    btn.disabled = false;
                }
            };
            input.click();
        }
    </script>